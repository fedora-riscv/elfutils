--- elfutils/libelf/ChangeLog
+++ elfutils/libelf/ChangeLog
@@ -529,6 +529,49 @@
 	If section content hasn't been read yet, do it before looking for the
 	block size.  If no section data present, infer size of section header.
 
+2005-05-17  Jakub Jelinek  <jakub@redhat.com>
+
+	* elf32_getphdr.c (elfw2(LIBELFBITS,getphdr)): Check if program header
+	table fits into object's bounds.
+	* elf_getshstrndx.c (elf_getshstrndx): Add elf->start_offset to
+	elf->map_address.  Check if first section header fits into object's
+	bounds.
+	* elf32_getshdr.c (elfw2(LIBELFBITS,getshdr)):
+	Check if section header table fits into object's bounds.
+	* elf_begin.c (get_shnum): Ensure section headers fits into
+	object's bounds.
+	(file_read_elf): Make sure scncnt is small enough to allocate both
+	ElfXX_Shdr and Elf_Scn array.  Make sure section and program header
+	tables fit into object's bounds.  Avoid memory leak on failure.
+
+2005-05-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* libelfP.h (INVALID_NDX): Define.
+	* gelf_getdyn.c (gelf_getdyn): Use it.  Remove ndx < 0 test if any.
+	* gelf_getlib.c (gelf_getlib): Likewise.
+	* gelf_getmove.c (gelf_getmove): Likewise.
+	* gelf_getrel.c (gelf_getrel): Likewise.
+	* gelf_getrela.c (gelf_getrela): Likewise.
+	* gelf_getsym.c (gelf_getsym): Likewise.
+	* gelf_getsyminfo.c (gelf_getsyminfo): Likewise.
+	* gelf_getsymshndx.c (gelf_getsymshndx): Likewise.
+	* gelf_getversym.c (gelf_getversym): Likewise.
+	* gelf_update_dyn.c (gelf_update_dyn): Likewise.
+	* gelf_update_lib.c (gelf_update_lib): Likewise.
+	* gelf_update_move.c (gelf_update_move): Likewise.
+	* gelf_update_rel.c (gelf_update_rel): Likewise.
+	* gelf_update_rela.c (gelf_update_rela): Likewise.
+	* gelf_update_sym.c (gelf_update_sym): Likewise.
+	* gelf_update_syminfo.c (gelf_update_syminfo): Likewise.
+	* gelf_update_symshndx.c (gelf_update_symshndx): Likewise.
+	* gelf_update_versym.c (gelf_update_versym): Likewise.
+	* elf_newscn.c (elf_newscn): Check for overflow.
+	* elf32_updatefile.c (__elfw2(LIBELFBITS,updatemmap)): Likewise.
+	(__elfw2(LIBELFBITS,updatefile)): Likewise.
+	* elf_begin.c (file_read_elf): Likewise.
+	* elf32_newphdr.c (elfw2(LIBELFBITS,newphdr)): Likewise.
+	* elf_getarsym.c (elf_getarsym): Likewise.
+	* elf32_getshdr.c (elfw2(LIBELFBITS,getshdr)): Likewise.
 2005-05-11  Ulrich Drepper  <drepper@redhat.com>
 
 	* elf.h: Update again.
--- elfutils/libelf/elf32_getphdr.c
+++ elfutils/libelf/elf32_getphdr.c
@@ -105,6 +105,16 @@ __elfw2(LIBELFBITS,getphdr_wrlock) (elf)
 
       if (elf->map_address != NULL)
 	{
+	  /* First see whether the information in the ELF header is
+	     valid and it does not ask for too much.  */
+	  if (unlikely (ehdr->e_phoff >= elf->maximum_size)
+	      || unlikely (ehdr->e_phoff + size > elf->maximum_size))
+	    {
+	      /* Something is wrong.  */
+	      __libelf_seterrno (ELF_E_INVALID_PHDR);
+	      goto out;
+	    }
+
 	  /* All the data is already mapped.  Use it.  */
 	  void *file_phdr = ((char *) elf->map_address
 			     + elf->start_offset + ehdr->e_phoff);
--- elfutils/libelf/elf32_getshdr.c
+++ elfutils/libelf/elf32_getshdr.c
@@ -1,5 +1,5 @@
 /* Return section header.
-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2005, 2007 Red Hat, Inc.
+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2005, 2007, 2008 Red Hat, Inc.
    This file is part of Red Hat elfutils.
    Written by Ulrich Drepper <drepper@redhat.com>, 1998.
 
@@ -81,7 +81,8 @@ load_shdr_wrlock (Elf_Scn *scn)
     goto out;
 
   size_t shnum;
-  if (__elf_getshnum_rdlock (elf, &shnum) != 0)
+  if (__elf_getshnum_rdlock (elf, &shnum) != 0
+      || shnum > SIZE_MAX / sizeof (ElfW2(LIBELFBITS,Shdr)))
     goto out;
   size_t size = shnum * sizeof (ElfW2(LIBELFBITS,Shdr));
 
@@ -98,6 +99,16 @@ load_shdr_wrlock (Elf_Scn *scn)
 
   if (elf->map_address != NULL)
     {
+      /* First see whether the information in the ELF header is
+	 valid and it does not ask for too much.  */
+      if (unlikely (ehdr->e_shoff >= elf->maximum_size)
+	  || unlikely (ehdr->e_shoff + size > elf->maximum_size))
+	{
+	  /* Something is wrong.  */
+	  __libelf_seterrno (ELF_E_INVALID_SECTION_HEADER);
+	  goto free_and_out;
+	}
+
       ElfW2(LIBELFBITS,Shdr) *notcvt;
 
       /* All the data is already mapped.  If we could use it
--- elfutils/libelf/elf32_newphdr.c
+++ elfutils/libelf/elf32_newphdr.c
@@ -124,6 +124,12 @@ elfw2(LIBELFBITS,newphdr) (elf, count)
   else if (elf->state.ELFW(elf,LIBELFBITS).ehdr->e_phnum != count
 	   || elf->state.ELFW(elf,LIBELFBITS).phdr == NULL)
     {
+      if (unlikely (count > SIZE_MAX / sizeof (ElfW2(LIBELFBITS,Phdr))))
+	{
+	  result = NULL;
+	  goto out;
+	}
+
       /* Allocate a new program header with the appropriate number of
 	 elements.  */
       result = (ElfW2(LIBELFBITS,Phdr) *)
--- elfutils/libelf/elf32_updatefile.c
+++ elfutils/libelf/elf32_updatefile.c
@@ -220,6 +220,9 @@ __elfw2(LIBELFBITS,updatemmap) (Elf *elf
   /* Write all the sections.  Well, only those which are modified.  */
   if (shnum > 0)
     {
+      if (unlikely (shnum > SIZE_MAX / sizeof (Elf_Scn *)))
+ 	return 1;
+
       Elf_ScnList *list = &elf->state.ELFW(elf,LIBELFBITS).scns;
       Elf_Scn **scns = (Elf_Scn **) alloca (shnum * sizeof (Elf_Scn *));
       char *const shdr_start = ((char *) elf->map_address + elf->start_offset
@@ -633,6 +636,10 @@ __elfw2(LIBELFBITS,updatefile) (Elf *elf
   /* Write all the sections.  Well, only those which are modified.  */
   if (shnum > 0)
     {
+      if (unlikely (shnum > SIZE_MAX / (sizeof (Elf_Scn *)
+					+ sizeof (ElfW2(LIBELFBITS,Shdr)))))
+	return 1;
+
       off_t shdr_offset = elf->start_offset + ehdr->e_shoff;
 #if EV_NUM != 2
       xfct_t shdr_fctp = __elf_xfctstom[__libelf_version - 1][EV_CURRENT - 1][ELFW(ELFCLASS, LIBELFBITS) - 1][ELF_T_SHDR];
--- elfutils/libelf/elf_begin.c
+++ elfutils/libelf/elf_begin.c
@@ -165,7 +165,8 @@ get_shnum (void *map_address, unsigned c
 
       if (unlikely (result == 0) && ehdr.e32->e_shoff != 0)
 	{
-	  if (ehdr.e32->e_shoff + sizeof (Elf32_Shdr) > maxsize)
+	  if (unlikely (ehdr.e32->e_shoff >= maxsize)
+	      || unlikely (ehdr.e32->e_shoff + sizeof (Elf32_Shdr) > maxsize))
 	    /* Cannot read the first section header.  */
 	    return 0;
 
@@ -213,7 +214,8 @@ get_shnum (void *map_address, unsigned c
 
       if (unlikely (result == 0) && ehdr.e64->e_shoff != 0)
 	{
-	  if (ehdr.e64->e_shoff + sizeof (Elf64_Shdr) > maxsize)
+	  if (unlikely (ehdr.e64->e_shoff >= maxsize)
+	      || unlikely (ehdr.e64->e_shoff + sizeof (Elf64_Shdr) > maxsize))
 	    /* Cannot read the first section header.  */
 	    return 0;
 
@@ -285,6 +287,15 @@ file_read_elf (int fildes, void *map_add
     /* Could not determine the number of sections.  */
     return NULL;
 
+  /* Check for too many sections.  */
+  if (e_ident[EI_CLASS] == ELFCLASS32)
+    {
+      if (scncnt > SIZE_MAX / (sizeof (Elf_Scn) + sizeof (Elf32_Shdr)))
+	return NULL;
+    }
+  else if (scncnt > SIZE_MAX / (sizeof (Elf_Scn) + sizeof (Elf64_Shdr)))
+    return NULL;
+
   /* We can now allocate the memory.  */
   Elf *elf = allocate_elf (fildes, map_address, offset, maxsize, cmd, parent,
 			   ELF_K_ELF, scncnt * sizeof (Elf_Scn));
@@ -318,13 +329,31 @@ file_read_elf (int fildes, void *map_add
 	{
 	  /* We can use the mmapped memory.  */
 	  elf->state.elf32.ehdr = ehdr;
+
+	  if (unlikely (ehdr->e_shoff >= maxsize)
+	      || unlikely (ehdr->e_shoff
+			   + scncnt * sizeof (Elf32_Shdr) > maxsize))
+	    {
+	    free_and_out:
+	      free (elf);
+	      __libelf_seterrno (ELF_E_INVALID_FILE);
+	      return NULL;
+	    }
 	  elf->state.elf32.shdr
 	    = (Elf32_Shdr *) ((char *) ehdr + ehdr->e_shoff);
+
 	  if (ehdr->e_phnum > 0)
+	    {
 	    /* Assign a value only if there really is a program
 	       header.  Otherwise the value remains NULL.  */
+	      if (unlikely (ehdr->e_phoff >= maxsize)
+		  || unlikely (ehdr->e_phoff
+			       + ehdr->e_phnum
+			       * sizeof (Elf32_Phdr) > maxsize))
+		goto free_and_out;
 	    elf->state.elf32.phdr
 	      = (Elf32_Phdr *) ((char *) ehdr + ehdr->e_phoff);
+	    }
 
 	  for (size_t cnt = 0; cnt < scncnt; ++cnt)
 	    {
@@ -406,13 +435,26 @@ file_read_elf (int fildes, void *map_add
 	{
 	  /* We can use the mmapped memory.  */
 	  elf->state.elf64.ehdr = ehdr;
+
+	  if (unlikely (ehdr->e_shoff >= maxsize)
+	      || unlikely (ehdr->e_shoff
+			   + scncnt * sizeof (Elf32_Shdr) > maxsize))
+	    goto free_and_out;
 	  elf->state.elf64.shdr
 	    = (Elf64_Shdr *) ((char *) ehdr + ehdr->e_shoff);
+
 	  if (ehdr->e_phnum > 0)
+	    {
 	    /* Assign a value only if there really is a program
 	       header.  Otherwise the value remains NULL.  */
+	      if (unlikely (ehdr->e_phoff >= maxsize)
+		  || unlikely (ehdr->e_phoff
+			       + ehdr->e_phnum
+			       * sizeof (Elf32_Phdr) > maxsize))
+		goto free_and_out;
 	    elf->state.elf64.phdr
 	      = (Elf64_Phdr *) ((char *) ehdr + ehdr->e_phoff);
+	    }
 
 	  for (size_t cnt = 0; cnt < scncnt; ++cnt)
 	    {
--- elfutils/libelf/elf_getarsym.c
+++ elfutils/libelf/elf_getarsym.c
@@ -179,6 +179,9 @@ elf_getarsym (elf, ptr)
       size_t index_size = atol (tmpbuf);
 
       if (SARMAG + sizeof (struct ar_hdr) + index_size > elf->maximum_size
+#if SIZE_MAX <= 4294967295U
+	  || n >= SIZE_MAX / sizeof (Elf_Arsym)
+#endif
 	  || n * sizeof (uint32_t) > index_size)
 	{
 	  /* This index table cannot be right since it does not fit into
--- elfutils/libelf/elf_getshstrndx.c
+++ elfutils/libelf/elf_getshstrndx.c
@@ -125,10 +125,25 @@ elf_getshstrndx (elf, dst)
 	      if (elf->map_address != NULL
 		  && elf->state.elf32.ehdr->e_ident[EI_DATA] == MY_ELFDATA
 		  && (ALLOW_UNALIGNED
-		      || (((size_t) ((char *) elf->map_address + offset))
+		      || (((size_t) ((char *) elf->map_address
+			   + elf->start_offset + offset))
 			  & (__alignof__ (Elf32_Shdr) - 1)) == 0))
+		{
+		  /* First see whether the information in the ELF header is
+		     valid and it does not ask for too much.  */
+		  if (unlikely (offset + sizeof (Elf32_Shdr)
+				> elf->maximum_size))
+		    {
+		      /* Something is wrong.  */
+		      __libelf_seterrno (ELF_E_INVALID_SECTION_HEADER);
+		      result = -1;
+		      goto out;
+		    }
+
 		/* We can directly access the memory.  */
-		num = ((Elf32_Shdr *) (elf->map_address + offset))->sh_link;
+		  num = ((Elf32_Shdr *) (elf->map_address + elf->start_offset
+					 + offset))->sh_link;
+		}
 	      else
 		{
 		  /* We avoid reading in all the section headers.  Just read
@@ -163,10 +178,25 @@ elf_getshstrndx (elf, dst)
 	      if (elf->map_address != NULL
 		  && elf->state.elf64.ehdr->e_ident[EI_DATA] == MY_ELFDATA
 		  && (ALLOW_UNALIGNED
-		      || (((size_t) ((char *) elf->map_address + offset))
+		      || (((size_t) ((char *) elf->map_address
+			   + elf->start_offset + offset))
 			  & (__alignof__ (Elf64_Shdr) - 1)) == 0))
+		{
+		  /* First see whether the information in the ELF header is
+		     valid and it does not ask for too much.  */
+		  if (unlikely (offset + sizeof (Elf64_Shdr)
+				> elf->maximum_size))
+		    {
+		      /* Something is wrong.  */
+		      __libelf_seterrno (ELF_E_INVALID_SECTION_HEADER);
+		      result = -1;
+		      goto out;
+		    }
+
 		/* We can directly access the memory.  */
-		num = ((Elf64_Shdr *) (elf->map_address + offset))->sh_link;
+		  num = ((Elf64_Shdr *) (elf->map_address
+			 + elf->start_offset + offset))->sh_link;
+		}
 	      else
 		{
 		  /* We avoid reading in all the section headers.  Just read
--- elfutils/libelf/elf_newscn.c
+++ elfutils/libelf/elf_newscn.c
@@ -104,10 +104,18 @@ elf_newscn (elf)
   else
     {
       /* We must allocate a new element.  */
-      Elf_ScnList *newp;
+      Elf_ScnList *newp = NULL;
 
       assert (elf->state.elf.scnincr > 0);
 
+      if (
+#if SIZE_MAX <= 4294967295U
+	  likely (elf->state.elf.scnincr
+		  < SIZE_MAX / 2 / sizeof (Elf_Scn) - sizeof (Elf_ScnList))
+#else
+	  1
+#endif
+	  )
       newp = (Elf_ScnList *) calloc (sizeof (Elf_ScnList)
 				     + ((elf->state.elf.scnincr *= 2)
 					* sizeof (Elf_Scn)), 1);
--- elfutils/libelf/gelf_getdyn.c
+++ elfutils/libelf/gelf_getdyn.c
@@ -93,7 +93,8 @@ gelf_getdyn (data, ndx, dst)
 	 table entries has to be adopted.  The user better has provided
 	 a buffer where we can store the information.  While copying the
 	 data we are converting the format.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Dyn) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Dyn)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Dyn) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -114,7 +115,8 @@ gelf_getdyn (data, ndx, dst)
 
       /* The data is already in the correct form.  Just make sure the
 	 index is OK.  */
-      if (unlikely ((ndx + 1) * sizeof (GElf_Dyn) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, GElf_Dyn)
+	  || unlikely ((ndx + 1) * sizeof (GElf_Dyn) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_getlib.c
+++ elfutils/libelf/gelf_getlib.c
@@ -86,7 +86,8 @@ gelf_getlib (data, ndx, dst)
   /* The data is already in the correct form.  Just make sure the
      index is OK.  */
   GElf_Lib *result = NULL;
-  if (unlikely ((ndx + 1) * sizeof (GElf_Lib) > data->d_size))
+  if (INVALID_NDX (ndx, GElf_Lib)
+      || unlikely ((ndx + 1) * sizeof (GElf_Lib) > data->d_size))
     __libelf_seterrno (ELF_E_INVALID_INDEX);
   else
     {
--- elfutils/libelf/gelf_getmove.c
+++ elfutils/libelf/gelf_getmove.c
@@ -83,7 +83,8 @@ gelf_getmove (data, ndx, dst)
 
   /* The data is already in the correct form.  Just make sure the
      index is OK.  */
-  if (unlikely ((ndx + 1) * sizeof (GElf_Move) > data->d_size))
+  if (INVALID_NDX (ndx, GElf_Move)
+      || unlikely ((ndx + 1) * sizeof (GElf_Move) > data->d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
       goto out;
--- elfutils/libelf/gelf_getrela.c
+++ elfutils/libelf/gelf_getrela.c
@@ -71,12 +71,6 @@ gelf_getrela (data, ndx, dst)
   if (data_scn == NULL)
     return NULL;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return NULL;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_RELA))
     {
       __libelf_seterrno (ELF_E_INVALID_HANDLE);
@@ -93,7 +87,8 @@ gelf_getrela (data, ndx, dst)
   if (scn->elf->class == ELFCLASS32)
     {
       /* We have to convert the data.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Rela) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Rela)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Rela) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  result = NULL;
@@ -114,7 +109,8 @@ gelf_getrela (data, ndx, dst)
     {
       /* Simply copy the data after we made sure we are actually getting
 	 correct data.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Rela) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Rela)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Rela) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  result = NULL;
--- elfutils/libelf/gelf_getrel.c
+++ elfutils/libelf/gelf_getrel.c
@@ -71,12 +71,6 @@ gelf_getrel (data, ndx, dst)
   if (data_scn == NULL)
     return NULL;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return NULL;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_REL))
     {
       __libelf_seterrno (ELF_E_INVALID_HANDLE);
@@ -93,7 +87,8 @@ gelf_getrel (data, ndx, dst)
   if (scn->elf->class == ELFCLASS32)
     {
       /* We have to convert the data.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Rel) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Rel)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Rel) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  result = NULL;
@@ -113,7 +108,8 @@ gelf_getrel (data, ndx, dst)
     {
       /* Simply copy the data after we made sure we are actually getting
 	 correct data.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Rel) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Rel)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Rel) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  result = NULL;
--- elfutils/libelf/gelf_getsym.c
+++ elfutils/libelf/gelf_getsym.c
@@ -90,7 +90,8 @@ gelf_getsym (data, ndx, dst)
 	 table entries has to be adopted.  The user better has provided
 	 a buffer where we can store the information.  While copying the
 	 data we are converting the format.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Sym) > data->d_size))
+      if (INVALID_NDX (ndx, Elf32_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Sym) > data->d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -119,7 +120,8 @@ gelf_getsym (data, ndx, dst)
 
       /* The data is already in the correct form.  Just make sure the
 	 index is OK.  */
-      if (unlikely ((ndx + 1) * sizeof (GElf_Sym) > data->d_size))
+      if (INVALID_NDX (ndx, GElf_Sym)
+	  || unlikely ((ndx + 1) * sizeof (GElf_Sym) > data->d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_getsyminfo.c
+++ elfutils/libelf/gelf_getsyminfo.c
@@ -84,7 +84,8 @@ gelf_getsyminfo (data, ndx, dst)
 
   /* The data is already in the correct form.  Just make sure the
      index is OK.  */
-  if (unlikely ((ndx + 1) * sizeof (GElf_Syminfo) > data->d_size))
+  if (INVALID_NDX (ndx, GElf_Syminfo)
+      || unlikely ((ndx + 1) * sizeof (GElf_Syminfo) > data->d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
       goto out;
--- elfutils/libelf/gelf_getsymshndx.c
+++ elfutils/libelf/gelf_getsymshndx.c
@@ -90,7 +90,9 @@ gelf_getsymshndx (symdata, shndxdata, nd
      section index table.  */
   if (likely (shndxdata_scn != NULL))
     {
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Word) > shndxdata_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Word)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Word)
+		       > shndxdata_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -110,7 +112,8 @@ gelf_getsymshndx (symdata, shndxdata, nd
 	 table entries has to be adopted.  The user better has provided
 	 a buffer where we can store the information.  While copying the
 	 data we are converting the format.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Sym) > symdata->d_size))
+      if (INVALID_NDX (ndx, Elf32_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Sym) > symdata->d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -139,7 +142,8 @@ gelf_getsymshndx (symdata, shndxdata, nd
 
       /* The data is already in the correct form.  Just make sure the
 	 index is OK.  */
-      if (unlikely ((ndx + 1) * sizeof (GElf_Sym) > symdata->d_size))
+      if (INVALID_NDX (ndx, GElf_Sym)
+	  || unlikely ((ndx + 1) * sizeof (GElf_Sym) > symdata->d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_getversym.c
+++ elfutils/libelf/gelf_getversym.c
@@ -92,7 +92,8 @@ gelf_getversym (data, ndx, dst)
 
   /* The data is already in the correct form.  Just make sure the
      index is OK.  */
-  if (unlikely ((ndx + 1) * sizeof (GElf_Versym) > data->d_size))
+  if (INVALID_NDX (ndx, GElf_Versym)
+      || unlikely ((ndx + 1) * sizeof (GElf_Versym) > data->d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
       result = NULL;
--- elfutils/libelf/gelf_update_dyn.c
+++ elfutils/libelf/gelf_update_dyn.c
@@ -71,12 +71,6 @@ gelf_update_dyn (data, ndx, src)
   if (data == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_DYN))
     {
       /* The type of the data better should match.  */
@@ -102,7 +96,8 @@ gelf_update_dyn (data, ndx, src)
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Dyn) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Dyn)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Dyn) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -116,7 +111,8 @@ gelf_update_dyn (data, ndx, src)
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Dyn) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Dyn)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Dyn) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_lib.c
+++ elfutils/libelf/gelf_update_lib.c
@@ -68,12 +68,6 @@ gelf_update_lib (data, ndx, src)
   if (data == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   Elf_Data_Scn *data_scn = (Elf_Data_Scn *) data;
   if (unlikely (data_scn->d.d_type != ELF_T_LIB))
     {
@@ -87,7 +81,8 @@ gelf_update_lib (data, ndx, src)
 
   /* Check whether we have to resize the data buffer.  */
   int result = 0;
-  if (unlikely ((ndx + 1) * sizeof (Elf64_Lib) > data_scn->d.d_size))
+  if (INVALID_NDX (ndx, Elf64_Lib)
+      || unlikely ((ndx + 1) * sizeof (Elf64_Lib) > data_scn->d.d_size))
     __libelf_seterrno (ELF_E_INVALID_INDEX);
   else
     {
--- elfutils/libelf/gelf_update_move.c
+++ elfutils/libelf/gelf_update_move.c
@@ -75,7 +75,7 @@ gelf_update_move (data, ndx, src)
   assert (sizeof (GElf_Move) == sizeof (Elf64_Move));
 
   /* Check whether we have to resize the data buffer.  */
-  if (unlikely (ndx < 0)
+  if (INVALID_NDX (ndx, GElf_Move)
       || unlikely ((ndx + 1) * sizeof (GElf_Move) > data_scn->d.d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
--- elfutils/libelf/gelf_update_rela.c
+++ elfutils/libelf/gelf_update_rela.c
@@ -68,12 +68,6 @@ gelf_update_rela (Elf_Data *dst, int ndx
   if (dst == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_RELA))
     {
       /* The type of the data better should match.  */
@@ -101,7 +95,8 @@ gelf_update_rela (Elf_Data *dst, int ndx
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Rela) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Rela)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Rela) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -117,7 +112,8 @@ gelf_update_rela (Elf_Data *dst, int ndx
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Rela) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Rela)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Rela) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_rel.c
+++ elfutils/libelf/gelf_update_rel.c
@@ -68,12 +68,6 @@ gelf_update_rel (Elf_Data *dst, int ndx,
   if (dst == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_REL))
     {
       /* The type of the data better should match.  */
@@ -99,7 +93,8 @@ gelf_update_rel (Elf_Data *dst, int ndx,
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Rel) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Rel)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Rel) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -114,7 +109,8 @@ gelf_update_rel (Elf_Data *dst, int ndx,
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Rel) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Rel)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Rel) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_sym.c
+++ elfutils/libelf/gelf_update_sym.c
@@ -72,12 +72,6 @@ gelf_update_sym (data, ndx, src)
   if (data == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_SYM))
     {
       /* The type of the data better should match.  */
@@ -102,7 +96,8 @@ gelf_update_sym (data, ndx, src)
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Sym) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Sym) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -125,7 +120,8 @@ gelf_update_sym (data, ndx, src)
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Sym) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Sym) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_syminfo.c
+++ elfutils/libelf/gelf_update_syminfo.c
@@ -72,12 +72,6 @@ gelf_update_syminfo (data, ndx, src)
   if (data == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_SYMINFO))
     {
       /* The type of the data better should match.  */
@@ -93,7 +87,8 @@ gelf_update_syminfo (data, ndx, src)
   rwlock_wrlock (scn->elf->lock);
 
   /* Check whether we have to resize the data buffer.  */
-  if (unlikely ((ndx + 1) * sizeof (GElf_Syminfo) > data_scn->d.d_size))
+  if (INVALID_NDX (ndx, GElf_Syminfo)
+      || unlikely ((ndx + 1) * sizeof (GElf_Syminfo) > data_scn->d.d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
       goto out;
--- elfutils/libelf/gelf_update_symshndx.c
+++ elfutils/libelf/gelf_update_symshndx.c
@@ -77,12 +77,6 @@ gelf_update_symshndx (symdata, shndxdata
   if (symdata == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (symdata_scn->d.d_type != ELF_T_SYM))
     {
       /* The type of the data better should match.  */
@@ -128,7 +122,8 @@ gelf_update_symshndx (symdata, shndxdata
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Sym) > symdata_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Sym) > symdata_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -151,7 +146,8 @@ gelf_update_symshndx (symdata, shndxdata
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Sym) > symdata_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Sym) > symdata_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_versym.c
+++ elfutils/libelf/gelf_update_versym.c
@@ -75,7 +75,7 @@ gelf_update_versym (data, ndx, src)
   assert (sizeof (GElf_Versym) == sizeof (Elf64_Versym));
 
   /* Check whether we have to resize the data buffer.  */
-  if (unlikely (ndx < 0)
+  if (INVALID_NDX (ndx, GElf_Versym)
       || unlikely ((ndx + 1) * sizeof (GElf_Versym) > data_scn->d.d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
--- elfutils/libelf/libelfP.h
+++ elfutils/libelf/libelfP.h
@@ -611,4 +611,13 @@ extern uint32_t __libelf_crc32 (uint32_t
 /* Align offset to 4 bytes as needed for note name and descriptor data.  */
 #define NOTE_ALIGN(n)	(((n) + 3) & -4U)
 
+/* Convenience macro.  Assumes int NDX and TYPE with size at least
+   2 bytes.  */
+#if SIZE_MAX > 4294967295U
+# define INVALID_NDX(ndx, type) unlikely (ndx < 0)
+#else
+# define INVALID_NDX(ndx, type) \
+  unlikely ((unsigned int) (ndx) >= SIZE_MAX / sizeof (type))
+#endif
+
 #endif  /* libelfP.h */
--- elfutils/po/es.po
+++ elfutils/po/es.po
@@ -1,14 +1,10 @@
-# Fedora Spanish Translation of elfutils.
-# Domingo Becker <domingobecker@gmail.com>, 2009.
-# H√©ctor Daniel Cabrera <h.daniel.cabrera@gmail.com>, 2009.
-#
 msgid ""
 msgstr ""
 "Project-Id-Version: elfutils\n"
 "Report-Msgid-Bugs-To: http://bugzilla.redhat.com/\n"
-"POT-Creation-Date: 2009-04-24 14:08+0000\n"
+"POT-Creation-Date: 2009-04-09 14:04+0000\n"
 "PO-Revision-Date: \n"
-"Last-Translator: H√©ctor Daniel Cabrera <h.daniel.cabrera@gmail.com>\n"
+"Last-Translator: Claudio Rodrigo Pereyra Diaz <claudio@pereyradiaz.com.ar>\n"
 "Language-Team: Fedora Spanish <fedora-trans-es@redhat.com>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -19,7 +15,7 @@ msgstr ""
 #: ../lib/xmalloc.c:65
 #: ../lib/xmalloc.c:79
 #: ../src/readelf.c:2703
-#: ../src/readelf.c:3041
+#: ../src/readelf.c:3038
 #: ../src/unstrip.c:2086
 #: ../src/unstrip.c:2294
 #, c-format
@@ -60,7 +56,7 @@ msgid "invalid size of destination opera
 msgstr "tama√±o inv√°lido del operando destino"
 
 #: ../libelf/elf_error.c:108
-#: ../src/readelf.c:4592
+#: ../src/readelf.c:4589
 #, c-format
 msgid "invalid encoding"
 msgstr "codificaci√≥n inv√°lida"
@@ -96,7 +92,7 @@ msgstr "desplazamiento fuera de rango"
 
 #: ../libelf/elf_error.c:136
 msgid "invalid fmag field in archive header"
-msgstr "campo fmag no v√°lido en el encabezado del archivo"
+msgstr ""
 
 #: ../libelf/elf_error.c:140
 msgid "invalid archive file"
@@ -136,7 +132,7 @@ msgstr "secci√≥n inv√°lida"
 
 #: ../libelf/elf_error.c:180
 msgid "executable header not created first"
-msgstr "no se ha creado primero el encabezado ejecutable"
+msgstr ""
 
 #: ../libelf/elf_error.c:184
 msgid "file descriptor disabled"
@@ -159,8 +155,8 @@ msgid "invalid section header"
 msgstr "cabecera de secci√≥n inv√°lida"
 
 #: ../libelf/elf_error.c:208
-#: ../src/readelf.c:6062
-#: ../src/readelf.c:6163
+#: ../src/readelf.c:6055
+#: ../src/readelf.c:6156
 #, c-format
 msgid "invalid data"
 msgstr "datos inv√°lidos"
@@ -171,7 +167,7 @@ msgstr "codificaci√≥n de caracteres desc
 
 #: ../libelf/elf_error.c:216
 msgid "section `sh_size' too small for data"
-msgstr "el tama√±o de la secci√≥n `sh_size' es demasiado peque√±o para los datos "
+msgstr ""
 
 #: ../libelf/elf_error.c:220
 msgid "invalid section alignment"
@@ -183,7 +179,7 @@ msgstr "tama√±o de la entrada de la secc
 
 #: ../libelf/elf_error.c:228
 msgid "update() for write on read-only file"
-msgstr "update() para escribir sobre archivo de s√≥lo lectura"
+msgstr ""
 
 #: ../libelf/elf_error.c:232
 msgid "no such file"
@@ -191,11 +187,11 @@ msgstr "no hay tal archivo"
 
 #: ../libelf/elf_error.c:236
 msgid "only relocatable files can contain section groups"
-msgstr "solo los archivos realojables pueden contener grupos de secci√≥n"
+msgstr ""
 
 #: ../libelf/elf_error.c:241
 msgid "program header only allowed in executables, shared objects, and core files"
-msgstr "los encabezados de los programas solo son permitidos en archivos ejecutables, archivos principales, u objetos compartidos"
+msgstr ""
 
 #: ../libelf/elf_error.c:248
 msgid "file has no program header"
@@ -415,19 +411,19 @@ msgstr "directorio NULL en find_file"
 
 #: ../libdwfl/argp-std.c:70
 msgid "Find addresses from signatures found in COREFILE"
-msgstr "Busca direcciones desde firmas encontradas en COREFILE"
+msgstr ""
 
 #: ../libdwfl/argp-std.c:72
 msgid "Find addresses in files mapped into process PID"
-msgstr "Busca direcciones en archivos mapeados sobre procesos PID"
+msgstr ""
 
 #: ../libdwfl/argp-std.c:74
 msgid "Find addresses in files mapped as read from FILE in Linux /proc/PID/maps format"
-msgstr "Busca direcciones en archivos mapeados como le√≠dos desde FILE en formato Linux /proc/PID/maps"
+msgstr ""
 
 #: ../libdwfl/argp-std.c:76
 msgid "Find addresses in the running kernel"
-msgstr "Busca direcciones en el kernel que est√° ejecut√°ndose"
+msgstr ""
 
 #: ../libdwfl/argp-std.c:78
 #, fuzzy
@@ -436,7 +432,7 @@ msgstr "Reemplazar todos los &espacios c
 
 #: ../libdwfl/argp-std.c:80
 msgid "Search path for separate debuginfo files"
-msgstr "Busca caminos para deferentes arhivos debugingfo"
+msgstr ""
 
 #: ../libdwfl/argp-std.c:163
 #, fuzzy
@@ -635,7 +631,7 @@ msgstr "`N' s√≥lo tiene significado con 
 #: ../src/ar.c:197
 #, c-format
 msgid "MEMBER parameter required for 'a', 'b', and 'i' modifiers"
-msgstr "Los modificadres 'a', 'b', e 'i', requieren par√°metros MEMBR"
+msgstr ""
 
 #: ../src/ar.c:213
 #, fuzzy, c-format
@@ -669,7 +665,7 @@ msgstr "%s: se requiere un nombre de se√
 #: ../src/strip.c:203
 #: ../src/ld.c:957
 #: ../src/elflint.c:238
-#: ../src/addr2line.c:185
+#: ../src/addr2line.c:180
 #: ../src/findtextrel.c:170
 #: ../src/elfcmp.c:522
 #: ../src/ranlib.c:136
@@ -682,9 +678,6 @@ msgid ""
 "This is free software; see the source for copying conditions.  There is NO\n"
 "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
 msgstr ""
-"Copyright (C) %s Red Hat, Inc.\n"
-"El siguiente es un software libre; consulte el c√≥digo para conocer las condiciones de copiado. NO TIENE\n"
-"garant√≠a, ni siquiera para SU COMERCIALIZACION o PARA SER USADO CON UN FIN DETERMINADO.\n"
 
 #: ../src/ar.c:294
 #: ../src/nm.c:258
@@ -693,7 +686,7 @@ msgstr ""
 #: ../src/strip.c:208
 #: ../src/ld.c:962
 #: ../src/elflint.c:243
-#: ../src/addr2line.c:190
+#: ../src/addr2line.c:185
 #: ../src/findtextrel.c:175
 #: ../src/elfcmp.c:527
 #: ../src/ranlib.c:141
@@ -867,7 +860,7 @@ msgstr "Extra√±amente s√≥lo hay %d parti
 
 #: ../src/nm.c:79
 msgid "Display dynamic symbols instead of normal symbols"
-msgstr "Muestra s√≠mbolos din√°micos en lugar de s√≠mbolos normales"
+msgstr ""
 
 #: ../src/nm.c:80
 #, fuzzy
@@ -881,7 +874,7 @@ msgstr "Mostrar s√≥lo cuando el adaptado
 
 #: ../src/nm.c:83
 msgid "Include index for symbols from archive members"
-msgstr "Incluye √≠ndices para s√≠mbolos desde miembros de archivo"
+msgstr ""
 
 #: ../src/nm.c:85
 #: ../src/size.c:66
@@ -895,7 +888,7 @@ msgstr "Imprimir el nombre del archivo d
 
 #: ../src/nm.c:90
 msgid "Use the output format FORMAT.  FORMAT can be `bsd', `sysv' or `posix'.  The default is `sysv'"
-msgstr "Use el formato de salida FORMAT. FORMAT puede ser o bien `bsd', o `sysv', o `posix'. El establecido por defecto es `sysv'"
+msgstr ""
 
 #: ../src/nm.c:92
 #, fuzzy
@@ -910,7 +903,7 @@ msgstr "lo mismo que --format=posix"
 #: ../src/nm.c:94
 #: ../src/size.c:72
 msgid "Use RADIX for printing symbol values"
-msgstr "Utilice RADIX para imprimir valores de s√≠mbolo"
+msgstr ""
 
 #: ../src/nm.c:95
 #, fuzzy
@@ -946,7 +939,7 @@ msgid "Reverse the sense of the sort"
 msgstr "_Invertir orden"
 
 #: ../src/nm.c:103
-#: ../src/addr2line.c:75
+#: ../src/addr2line.c:73
 #: ../src/findtextrel.c:75
 #: ../src/elfcmp.c:75
 #: ../src/strings.c:83
@@ -1002,7 +995,7 @@ msgstr ""
 #: ../src/size.c:317
 #: ../src/size.c:326
 #: ../src/size.c:337
-#: ../src/strip.c:1815
+#: ../src/strip.c:1814
 #, fuzzy, c-format
 msgid "while closing '%s'"
 msgstr "error al cerrar la entrada `%s'"
@@ -1065,17 +1058,17 @@ msgstr "No se puede crear el componente 
 #: ../src/readelf.c:2722
 #: ../src/readelf.c:2758
 #: ../src/readelf.c:2820
-#: ../src/readelf.c:6312
-#: ../src/readelf.c:7178
-#: ../src/readelf.c:7323
-#: ../src/readelf.c:7392
+#: ../src/readelf.c:6305
+#: ../src/readelf.c:7171
+#: ../src/readelf.c:7316
+#: ../src/readelf.c:7385
 #: ../src/size.c:425
 #: ../src/size.c:499
 #: ../src/strip.c:482
 #: ../src/objdump.c:744
-#, fuzzy, c-format
+#, c-format
 msgid "cannot get section header string table index"
-msgstr "no se puede obtener √≠ndice de la tabla de la cadena del encabezado de secci√≥n"
+msgstr ""
 
 #: ../src/nm.c:766
 #, fuzzy, c-format
@@ -1114,7 +1107,7 @@ msgstr "no se reconoce el tipo de secci√
 #: ../src/nm.c:1012
 #, c-format
 msgid "%s: entry size in section `%s' is not what we expect"
-msgstr "%s: el tama√±o de la entrada en la secci√≥n `%s' no es el que esper√°bamos "
+msgstr ""
 
 #: ../src/nm.c:1016
 #, fuzzy, c-format
@@ -1148,9 +1141,8 @@ msgid "Display the ELF file header"
 msgstr "encabezado del fichero BFD versi√≥n %s\n"
 
 #: ../src/readelf.c:77
-#, fuzzy
 msgid "Display histogram of bucket list lengths"
-msgstr "Muestra histograma de la longitud de las listas de almacenamiento"
+msgstr ""
 
 #: ../src/readelf.c:78
 #, fuzzy
@@ -1182,9 +1174,8 @@ msgid "Display versioning information"
 msgstr "Mostrar la informaci√≥n de la versi√≥n."
 
 #: ../src/readelf.c:86
-#, fuzzy
 msgid "Display DWARF section content.  SECTION can be one of abbrev, aranges, frame, info, loc, line, ranges, pubnames, str, macinfo, or exception"
-msgstr "Muestra el contenido de la seccion DWARF. SECTION puede ser algo de lo siguiente: abbrev, aranges, frame, info, loc, line, ranges, pubnames, str, macinfo, or exception"
+msgstr ""
 
 #: ../src/readelf.c:89
 #, fuzzy
@@ -1193,11 +1184,11 @@ msgstr "_Ocultar notas"
 
 #: ../src/readelf.c:91
 msgid "Display architecture specific information (if any)"
-msgstr "Muestra informaci√≥n espec√≠fica de la arquitectura (si es que hubiera)"
+msgstr ""
 
 #: ../src/readelf.c:93
 msgid "Dump the uninterpreted contents of SECTION, by number or name"
-msgstr "Descarga los contenidos no interpretados de SECTION, por nombre o n√∫mero"
+msgstr ""
 
 #: ../src/readelf.c:95
 #, fuzzy
@@ -1222,7 +1213,7 @@ msgstr "Control del resultado:"
 #. Short description of program.
 #: ../src/readelf.c:108
 msgid "Print information from ELF file in human-readable form."
-msgstr "Imprime informaci√≥n desde el archivo ELF en una forma comprensible para los seres humanos. "
+msgstr ""
 
 #. Strings for arguments in help texts.
 #: ../src/readelf.c:112
@@ -1265,7 +1256,7 @@ msgstr "no se puede crear un descriptor 
 #: ../src/readelf.c:460
 #, c-format
 msgid "'%s' is not an archive, cannot print archive index"
-msgstr "'%s' no es un archivo, no se puede imprimir √≠ndice de archivo"
+msgstr ""
 
 #: ../src/readelf.c:465
 #, fuzzy, c-format
@@ -1439,22 +1430,22 @@ msgstr "%s (%s bytes)"
 #: ../src/readelf.c:769
 #, c-format
 msgid "  Size of program header entries:    %<PRId16> %s\n"
-msgstr "  Tama√±o de las entradas en el encabezado del programa:    %<PRId16> %s\n"
+msgstr ""
 
 #: ../src/readelf.c:772
 #, c-format
 msgid "  Number of program headers entries: %<PRId16>\n"
-msgstr "  Cantidad de entradas en los encabezados del programa: %<PRId16>\n"
+msgstr ""
 
 #: ../src/readelf.c:775
 #, c-format
 msgid "  Size of section header entries:    %<PRId16> %s\n"
-msgstr "  Tama√±o de las entradas en el encabezado de secci√≥n:    %<PRId16> %s\n"
+msgstr ""
 
 #: ../src/readelf.c:778
 #, c-format
 msgid "  Number of section headers entries: %<PRId16>"
-msgstr "  Cantidad de entradas en los encabezados de secci√≥n: %<PRId16>"
+msgstr ""
 
 #: ../src/readelf.c:785
 #, fuzzy, c-format
@@ -1517,7 +1508,7 @@ msgstr "%s: no se puede encontrar la sec
 
 #: ../src/readelf.c:871
 #: ../src/readelf.c:1025
-#: ../src/readelf.c:7343
+#: ../src/readelf.c:7336
 #: ../src/unstrip.c:352
 #: ../src/unstrip.c:376
 #: ../src/unstrip.c:426
@@ -1914,140 +1905,140 @@ msgstr[1] ""
 msgid "       Library                       Time Stamp          Checksum Version Flags"
 msgstr ""
 
-#: ../src/readelf.c:2832
+#: ../src/readelf.c:2830
 #, c-format
 msgid ""
 "\n"
 "Object attributes section [%2zu] '%s' of %<PRIu64> bytes at offset %#0<PRIx64>:\n"
 msgstr ""
 
-#: ../src/readelf.c:2848
+#: ../src/readelf.c:2846
 #, fuzzy
 msgid "  Owner          Size\n"
 msgstr "  Prop\t\tTama√±o datos\tDescripci√≥n\n"
 
-#: ../src/readelf.c:2874
+#: ../src/readelf.c:2872
 #, fuzzy, c-format
 msgid "  %-13s  %4<PRIu32>\n"
 msgstr "Pedido de servidor desconocida %<PRIu32>"
 
-#: ../src/readelf.c:2906
+#: ../src/readelf.c:2903
 #, fuzzy, c-format
 msgid "    %-4u %12<PRIu32>\n"
 msgstr "12 x 11 in"
 
 #. Tag_File
-#: ../src/readelf.c:2911
+#: ../src/readelf.c:2908
 #, fuzzy, c-format
 msgid "    File: %11<PRIu32>\n"
 msgstr "10 x 11 in"
 
-#: ../src/readelf.c:2946
+#: ../src/readelf.c:2943
 #, c-format
 msgid "      %s: %<PRId64>, %s\n"
 msgstr "      %s: %<PRId64>, %s\n"
 
-#: ../src/readelf.c:2949
+#: ../src/readelf.c:2946
 #, c-format
 msgid "      %s: %<PRId64>\n"
 msgstr "      %s: %<PRId64>\n"
 
-#: ../src/readelf.c:2952
+#: ../src/readelf.c:2949
 #, c-format
 msgid "      %s: %s\n"
 msgstr "      %s: %s\n"
 
-#: ../src/readelf.c:2959
+#: ../src/readelf.c:2956
 #, c-format
 msgid "      %u: %<PRId64>\n"
 msgstr "      %u: %<PRId64>\n"
 
-#: ../src/readelf.c:2962
+#: ../src/readelf.c:2959
 #, c-format
 msgid "      %u: %s\n"
 msgstr "      %u: %s\n"
 
-#: ../src/readelf.c:2997
+#: ../src/readelf.c:2994
 #, c-format
 msgid "%s+%#<PRIx64> <%s+%#<PRIx64>>"
 msgstr "%s+%#<PRIx64> <%s+%#<PRIx64>>"
 
-#: ../src/readelf.c:3000
+#: ../src/readelf.c:2997
 #, c-format
 msgid "%s+%#0*<PRIx64> <%s+%#<PRIx64>>"
 msgstr "%s+%#0*<PRIx64> <%s+%#<PRIx64>>"
 
-#: ../src/readelf.c:3005
+#: ../src/readelf.c:3002
 #, c-format
 msgid "%#<PRIx64> <%s+%#<PRIx64>>"
 msgstr "%#<PRIx64> <%s+%#<PRIx64>>"
 
-#: ../src/readelf.c:3008
+#: ../src/readelf.c:3005
 #, c-format
 msgid "%#0*<PRIx64> <%s+%#<PRIx64>>"
 msgstr "%#0*<PRIx64> <%s+%#<PRIx64>>"
 
-#: ../src/readelf.c:3014
+#: ../src/readelf.c:3011
 #, c-format
 msgid "%s+%#<PRIx64> <%s>"
 msgstr "%s+%#<PRIx64> <%s>"
 
-#: ../src/readelf.c:3017
+#: ../src/readelf.c:3014
 #, c-format
 msgid "%s+%#0*<PRIx64> <%s>"
 msgstr "%s+%#0*<PRIx64> <%s>"
 
-#: ../src/readelf.c:3021
+#: ../src/readelf.c:3018
 #, c-format
 msgid "%#<PRIx64> <%s>"
 msgstr "%#<PRIx64> <%s>"
 
-#: ../src/readelf.c:3024
+#: ../src/readelf.c:3021
 #, c-format
 msgid "%#0*<PRIx64> <%s>"
 msgstr "%#0*<PRIx64> <%s>"
 
-#: ../src/readelf.c:3029
+#: ../src/readelf.c:3026
 #, c-format
 msgid "%s+%#<PRIx64>"
 msgstr "%s+%#<PRIx64>"
 
-#: ../src/readelf.c:3032
+#: ../src/readelf.c:3029
 #, c-format
 msgid "%s+%#0*<PRIx64>"
 msgstr "%s+%#0*<PRIx64>"
 
-#: ../src/readelf.c:3140
+#: ../src/readelf.c:3137
 #, fuzzy, c-format
 msgid "unknown tag %hx"
 msgstr "l√≠nea %d: etiqueta desconocida: %s\n"
 
-#: ../src/readelf.c:3142
+#: ../src/readelf.c:3139
 #, fuzzy, c-format
 msgid "unknown user tag %hx"
 msgstr "Valor TAG desconocido: %lx"
 
-#: ../src/readelf.c:3352
+#: ../src/readelf.c:3349
 #, fuzzy, c-format
 msgid "unknown attribute %hx"
 msgstr "atributo de secci√≥n '%c' desconocido"
 
-#: ../src/readelf.c:3355
+#: ../src/readelf.c:3352
 #, fuzzy, c-format
 msgid "unknown user attribute %hx"
 msgstr "Nombres de atributos de usuario predeterminados:\n"
 
-#: ../src/readelf.c:3401
+#: ../src/readelf.c:3398
 #, fuzzy, c-format
 msgid "unknown form %<PRIx64>"
 msgstr "Valor FORM desconocido: %lx"
 
-#: ../src/readelf.c:4017
+#: ../src/readelf.c:4014
 #, fuzzy, c-format
 msgid "%*s[%4<PRIuMAX>] %s  <TRUNCATED>\n"
 msgstr "Fichero truncado"
 
-#: ../src/readelf.c:4030
+#: ../src/readelf.c:4027
 #, c-format
 msgid ""
 "\n"
@@ -2055,39 +2046,39 @@ msgid ""
 " [ Code]\n"
 msgstr ""
 
-#: ../src/readelf.c:4037
+#: ../src/readelf.c:4034
 #, c-format
 msgid ""
 "\n"
 "Abbreviation section at offset %<PRIu64>:\n"
 msgstr ""
 
-#: ../src/readelf.c:4050
+#: ../src/readelf.c:4047
 #, fuzzy, c-format
 msgid " *** error while reading abbreviation: %s\n"
 msgstr "Error al leer el disco."
 
-#: ../src/readelf.c:4066
+#: ../src/readelf.c:4063
 #, c-format
 msgid " [%5u] offset: %<PRId64>, children: %s, tag: %s\n"
 msgstr ""
 
-#: ../src/readelf.c:4069
+#: ../src/readelf.c:4066
 #, fuzzy
 msgid "yes"
 msgstr "s√≠"
 
-#: ../src/readelf.c:4069
+#: ../src/readelf.c:4066
 #, fuzzy
 msgid "no"
 msgstr "no"
 
-#: ../src/readelf.c:4105
+#: ../src/readelf.c:4102
 #, c-format
 msgid "cannot get .debug_aranges content: %s"
 msgstr ""
 
-#: ../src/readelf.c:4110
+#: ../src/readelf.c:4107
 #, c-format
 msgid ""
 "\n"
@@ -2098,130 +2089,130 @@ msgid_plural ""
 msgstr[0] ""
 msgstr[1] ""
 
-#: ../src/readelf.c:4140
+#: ../src/readelf.c:4137
 #, c-format
 msgid " [%*zu] ???\n"
 msgstr " [%*zu] ???\n"
 
-#: ../src/readelf.c:4142
+#: ../src/readelf.c:4139
 #, c-format
 msgid " [%*zu] start: %0#*<PRIx64>, length: %5<PRIu64>, CU DIE offset: %6<PRId64>\n"
 msgstr ""
 
-#: ../src/readelf.c:4161
+#: ../src/readelf.c:4158
 #, c-format
 msgid "cannot get .debug_ranges content: %s"
 msgstr ""
 
-#: ../src/readelf.c:4166
-#: ../src/readelf.c:4623
-#: ../src/readelf.c:5272
-#: ../src/readelf.c:5717
-#: ../src/readelf.c:5812
-#: ../src/readelf.c:5984
+#: ../src/readelf.c:4163
+#: ../src/readelf.c:4620
+#: ../src/readelf.c:5265
+#: ../src/readelf.c:5710
+#: ../src/readelf.c:5805
+#: ../src/readelf.c:5977
 #, c-format
 msgid ""
 "\n"
 "DWARF section [%2zu] '%s' at offset %#<PRIx64>:\n"
 msgstr ""
 
-#: ../src/readelf.c:4180
-#: ../src/readelf.c:5731
+#: ../src/readelf.c:4177
+#: ../src/readelf.c:5724
 #, fuzzy, c-format
 msgid " [%6tx]  <INVALID DATA>\n"
 msgstr "%F%P: declaraci√≥n inv√°lida de datos\n"
 
-#: ../src/readelf.c:4202
-#: ../src/readelf.c:5753
+#: ../src/readelf.c:4199
+#: ../src/readelf.c:5746
 #, fuzzy, c-format
 msgid " [%6tx]  base address %s\n"
 msgstr "    %8.8lx %8.8lx %8.8lx (direcci√≥n base)\n"
 
 #. We have an address range entry.
 #. First address range entry in a list.
-#: ../src/readelf.c:4213
+#: ../src/readelf.c:4210
 #, c-format
 msgid " [%6tx]  %s..%s\n"
 msgstr " [%6tx]  %s..%s\n"
 
-#: ../src/readelf.c:4215
+#: ../src/readelf.c:4212
 #, c-format
 msgid "           %s..%s\n"
 msgstr "           %s..%s\n"
 
-#: ../src/readelf.c:4612
-#: ../src/readelf.c:6050
-#: ../src/readelf.c:6152
+#: ../src/readelf.c:4609
+#: ../src/readelf.c:6043
+#: ../src/readelf.c:6145
 #, fuzzy, c-format
 msgid "cannot get %s content: %s"
 msgstr "No se puede obtener el nombre de la m√°quina (hostname)"
 
-#: ../src/readelf.c:4619
+#: ../src/readelf.c:4616
 #, c-format
 msgid ""
 "\n"
 "Call frame information section [%2zu] '%s' at offset %#<PRIx64>:\n"
 msgstr ""
 
-#: ../src/readelf.c:4646
-#: ../src/readelf.c:5306
+#: ../src/readelf.c:4643
+#: ../src/readelf.c:5299
 #, fuzzy, c-format
 msgid "invalid data in section [%zu] '%s'"
 msgstr "La secci√≥n BOUNDS en el archivo no es v√°lida."
 
-#: ../src/readelf.c:4668
+#: ../src/readelf.c:4665
 #, fuzzy, c-format
 msgid ""
 "\n"
 " [%6tx] Zero terminator\n"
 msgstr "terminador de linea desconocido"
 
-#: ../src/readelf.c:4746
+#: ../src/readelf.c:4739
 #, fuzzy
 msgid "FDE address encoding: "
 msgstr "Codificaci√≥n en una sola pasada"
 
-#: ../src/readelf.c:4752
+#: ../src/readelf.c:4745
 #, fuzzy
 msgid "LSDA pointer encoding: "
 msgstr "Codificaci√≥n en una sola pasada"
 
-#: ../src/readelf.c:4797
+#: ../src/readelf.c:4790
 #, fuzzy, c-format
 msgid "invalid augmentation encoding"
 msgstr "especificada una codificaci√≥n inv√°lida"
 
-#: ../src/readelf.c:4868
+#: ../src/readelf.c:4861
 #, fuzzy, c-format
 msgid " (offset: %#<PRIx64>)"
 msgstr "Desplazamiento horizontal"
 
-#: ../src/readelf.c:4875
+#: ../src/readelf.c:4868
 #, fuzzy, c-format
 msgid " (end offset: %#<PRIx64>)"
 msgstr "    Desplaz  Inicio   Fin\n"
 
-#: ../src/readelf.c:4902
+#: ../src/readelf.c:4895
 #, fuzzy, c-format
 msgid "   %-26sLSDA pointer: %#<PRIx64>\n"
 msgstr "\tNombre de la Tabla de Punteros \t\t"
 
-#: ../src/readelf.c:4948
+#: ../src/readelf.c:4941
 #, fuzzy, c-format
 msgid "cannot get attribute code: %s"
 msgstr "No se puede inicializar el c√≥digo de libbonoboui"
 
-#: ../src/readelf.c:4956
+#: ../src/readelf.c:4949
 #, fuzzy, c-format
 msgid "cannot get attribute form: %s"
 msgstr "No se puede a√±adir el atributo SMIMEEncKeyPrefs"
 
-#: ../src/readelf.c:4969
+#: ../src/readelf.c:4962
 #, fuzzy, c-format
 msgid "cannot get attribute value: %s"
 msgstr "No se puede a√±adir el atributo SMIMEEncKeyPrefs"
 
-#: ../src/readelf.c:5151
+#: ../src/readelf.c:5144
 #, c-format
 msgid ""
 "\n"
@@ -2229,44 +2220,44 @@ msgid ""
 " [Offset]\n"
 msgstr ""
 
-#: ../src/readelf.c:5176
+#: ../src/readelf.c:5169
 #, c-format
 msgid ""
 " Compilation unit at offset %<PRIu64>:\n"
 " Version: %<PRIu16>, Abbreviation section offset: %<PRIu64>, Address size: %<PRIu8>, Offset size: %<PRIu8>\n"
 msgstr ""
 
-#: ../src/readelf.c:5194
+#: ../src/readelf.c:5187
 #, c-format
 msgid "cannot get DIE at offset %<PRIu64> in section '%s': %s"
 msgstr ""
 
-#: ../src/readelf.c:5205
+#: ../src/readelf.c:5198
 #, fuzzy, c-format
 msgid "cannot get DIE offset: %s"
 msgstr "%s: no se puede desplazar a la posici√≥n %s"
 
-#: ../src/readelf.c:5213
+#: ../src/readelf.c:5206
 #, c-format
 msgid "cannot get tag of DIE at offset %<PRIu64> in section '%s': %s"
 msgstr ""
 
-#: ../src/readelf.c:5242
+#: ../src/readelf.c:5235
 #, fuzzy, c-format
 msgid "cannot get next DIE: %s\n"
 msgstr "No se puede obtener el nombre oficial de la m√°quina (hostname)"
 
-#: ../src/readelf.c:5249
+#: ../src/readelf.c:5242
 #, fuzzy, c-format
 msgid "cannot get next DIE: %s"
 msgstr "No se puede obtener el nombre oficial de la m√°quina (hostname)"
 
-#: ../src/readelf.c:5284
+#: ../src/readelf.c:5277
 #, fuzzy, c-format
 msgid "cannot get line data section data: %s"
 msgstr "%C: No se puede obtener el contenido de la secci√≥n - excepci√≥n de auto-importaci√≥n\n"
 
-#: ../src/readelf.c:5297
+#: ../src/readelf.c:5290
 #, fuzzy, c-format
 msgid ""
 "\n"
@@ -2274,7 +2265,7 @@ msgid ""
 msgstr "%s: error al escribir en el desplazamiento %s"
 
 #. Print what we got so far.
-#: ../src/readelf.c:5349
+#: ../src/readelf.c:5342
 #, c-format
 msgid ""
 "\n"
@@ -2290,33 +2281,33 @@ msgid ""
 "Opcodes:\n"
 msgstr ""
 
-#: ../src/readelf.c:5368
+#: ../src/readelf.c:5361
 #, c-format
 msgid "invalid data at offset %tu in section [%zu] '%s'"
 msgstr ""
 
-#: ../src/readelf.c:5383
+#: ../src/readelf.c:5376
 #, fuzzy, c-format
 msgid "  [%*<PRIuFAST8>]  %hhu argument\n"
 msgid_plural "  [%*<PRIuFAST8>]  %hhu arguments\n"
 msgstr[0] "argumento inv√°lido en"
 msgstr[1] ""
 
-#: ../src/readelf.c:5391
+#: ../src/readelf.c:5384
 #, fuzzy
 msgid ""
 "\n"
 "Directory table:"
 msgstr "Tabla del Cortafuegos:"
 
-#: ../src/readelf.c:5407
+#: ../src/readelf.c:5400
 msgid ""
 "\n"
 "File name table:\n"
 " Entry Dir   Time      Size      Name"
 msgstr ""
 
-#: ../src/readelf.c:5436
+#: ../src/readelf.c:5429
 #, fuzzy
 msgid ""
 "\n"
@@ -2325,94 +2316,94 @@ msgstr ""
 "\n"
 " Declaraciones de N√∫mero de L√≠nea:\n"
 
-#: ../src/readelf.c:5497
+#: ../src/readelf.c:5490
 #, c-format
 msgid " special opcode %u: address+%u = %s, line%+d = %zu\n"
 msgstr ""
 
-#: ../src/readelf.c:5517
+#: ../src/readelf.c:5510
 #, fuzzy, c-format
 msgid " extended opcode %u: "
 msgstr "  C√≥digo de operaci√≥n extendido %d: "
 
-#: ../src/readelf.c:5522
+#: ../src/readelf.c:5515
 #, fuzzy
 msgid "end of sequence"
 msgstr ""
 "Fin de la Secuencia\n"
 "\n"
 
-#: ../src/readelf.c:5537
+#: ../src/readelf.c:5530
 #, fuzzy, c-format
 msgid "set address to %s\n"
 msgstr "La direcci√≥n de la secci√≥n %s se estableci√≥ a "
 
-#: ../src/readelf.c:5558
+#: ../src/readelf.c:5551
 #, c-format
 msgid "define new file: dir=%u, mtime=%<PRIu64>, length=%<PRIu64>, name=%s\n"
 msgstr ""
 
 #. Unknown, ignore it.
-#: ../src/readelf.c:5567
+#: ../src/readelf.c:5560
 #, fuzzy
 msgid "unknown opcode"
 msgstr "c√≥digo de operaci√≥n desconocido"
 
 #. Takes no argument.
-#: ../src/readelf.c:5579
+#: ../src/readelf.c:5572
 #, fuzzy
 msgid " copy"
 msgstr "&Copiar"
 
-#: ../src/readelf.c:5589
+#: ../src/readelf.c:5582
 #, fuzzy, c-format
 msgid "advance address by %u to %s\n"
 msgstr "  L√≠nea de Avance por %d para %d\n"
 
-#: ../src/readelf.c:5600
+#: ../src/readelf.c:5593
 #, fuzzy, c-format
 msgid " advance line by constant %d to %<PRId64>\n"
 msgstr "  Avanzar el PC por la constante %lu a 0x%lx\n"
 
-#: ../src/readelf.c:5608
+#: ../src/readelf.c:5601
 #, fuzzy, c-format
 msgid " set file to %<PRIu64>\n"
 msgstr "No se pudieron cambiar permisos del archivo temporal"
 
-#: ../src/readelf.c:5618
+#: ../src/readelf.c:5611
 #, fuzzy, c-format
 msgid " set column to %<PRIu64>\n"
 msgstr "  Establecer la columna a %lu\n"
 
-#: ../src/readelf.c:5625
+#: ../src/readelf.c:5618
 #, fuzzy, c-format
 msgid " set '%s' to %<PRIuFAST8>\n"
 msgstr "<I>%s</I> fijo los modos del usuario <I>%s</I> a: %s"
 
 #. Takes no argument.
-#: ../src/readelf.c:5631
+#: ../src/readelf.c:5624
 #, fuzzy
 msgid " set basic block flag"
 msgstr "\t%d registro de cuenta de bloques b√°sicos\n"
 
-#: ../src/readelf.c:5641
+#: ../src/readelf.c:5634
 #, fuzzy, c-format
 msgid "advance address by constant %u to %s\n"
 msgstr "  Avanzar el PC por %lu para %lx\n"
 
-#: ../src/readelf.c:5657
+#: ../src/readelf.c:5650
 #, c-format
 msgid "advance address by fixed value %u to %s\n"
 msgstr ""
 
 #. Takes no argument.
-#: ../src/readelf.c:5666
+#: ../src/readelf.c:5659
 #, fuzzy
 msgid " set prologue end flag"
 msgstr "  Establecer prologue_end a true\n"
 
 #. Takes no argument.
-#: ../src/readelf.c:5671
+#: ../src/readelf.c:5664
 #, fuzzy
 msgid " set epilogue begin flag"
 msgstr "  Establecer epilogue_begin a true\n"
@@ -2420,45 +2411,45 @@ msgstr "  Establecer epilogue_begin a tr
 #. This is a new opcode the generator but not we know about.
 #. Read the parameters associated with it but then discard
 #. everything.  Read all the parameters for this opcode.
-#: ../src/readelf.c:5680
+#: ../src/readelf.c:5673
 #, c-format
 msgid " unknown opcode with %<PRIu8> parameter:"
 msgid_plural " unknown opcode with %<PRIu8> parameters:"
 msgstr[0] ""
 msgstr[1] ""
 
-#: ../src/readelf.c:5712
+#: ../src/readelf.c:5705
 #, c-format
 msgid "cannot get .debug_loc content: %s"
 msgstr ""
 
 #. First entry in a list.
-#: ../src/readelf.c:5767
+#: ../src/readelf.c:5760
 #, c-format
 msgid " [%6tx]  %s..%s"
 msgstr " [%6tx]  %s..%s"
 
-#: ../src/readelf.c:5769
+#: ../src/readelf.c:5762
 #, c-format
 msgid "           %s..%s"
 msgstr "           %s..%s"
 
-#: ../src/readelf.c:5822
+#: ../src/readelf.c:5815
 #, c-format
 msgid "cannot get macro information section data: %s"
 msgstr ""
 
-#: ../src/readelf.c:5901
+#: ../src/readelf.c:5894
 #, c-format
 msgid "%*s*** non-terminated string at end of section"
 msgstr ""
 
-#: ../src/readelf.c:5969
+#: ../src/readelf.c:5962
 #, c-format
 msgid " [%5d] DIE offset: %6<PRId64>, CU DIE offset: %6<PRId64>, name: %s\n"
 msgstr ""
 
-#: ../src/readelf.c:6008
+#: ../src/readelf.c:6001
 #, c-format
 msgid ""
 "\n"
@@ -2466,48 +2457,48 @@ msgid ""
 " %*s  String\n"
 msgstr ""
 
-#: ../src/readelf.c:6022
+#: ../src/readelf.c:6015
 #, fuzzy, c-format
 msgid " *** error while reading strings: %s\n"
 msgstr "Error al leer el disco."
 
-#: ../src/readelf.c:6042
+#: ../src/readelf.c:6035
 #, c-format
 msgid ""
 "\n"
 "Call frame search table section [%2zu] '.eh_frame_hdr':\n"
 msgstr ""
 
-#: ../src/readelf.c:6144
+#: ../src/readelf.c:6137
 #, c-format
 msgid ""
 "\n"
 "Exception handling table section [%2zu] '.gcc_except_table':\n"
 msgstr ""
 
-#: ../src/readelf.c:6167
+#: ../src/readelf.c:6160
 #, fuzzy, c-format
 msgid " LPStart encoding:    %#x "
 msgstr ": codificaci√≥n desconocida"
 
-#: ../src/readelf.c:6179
+#: ../src/readelf.c:6172
 #, fuzzy, c-format
 msgid " TType encoding:      %#x "
 msgstr ": codificaci√≥n desconocida"
 
-#: ../src/readelf.c:6193
+#: ../src/readelf.c:6186
 #, fuzzy, c-format
 msgid " Call site encoding:  %#x "
 msgstr "Codificaci√≥n en una sola pasada"
 
-#: ../src/readelf.c:6206
+#: ../src/readelf.c:6199
 #, fuzzy
 msgid ""
 "\n"
 " Call site table:"
 msgstr "[<tipo>:][<tabla>:]<nombre_de_archivo>"
 
-#: ../src/readelf.c:6220
+#: ../src/readelf.c:6213
 #, c-format
 msgid ""
 " [%4u] Call site start:   %#<PRIx64>\n"
@@ -2516,146 +2507,142 @@ msgid ""
 "        Action:            %u\n"
 msgstr ""
 
-#: ../src/readelf.c:6280
+#: ../src/readelf.c:6273
 #, fuzzy, c-format
 msgid "invalid TType encoding"
 msgstr "especificada una codificaci√≥n inv√°lida"
 
-#: ../src/readelf.c:6303
+#: ../src/readelf.c:6296
 #, c-format
 msgid "cannot get debug context descriptor: %s"
 msgstr ""
 
-#: ../src/readelf.c:6438
-#: ../src/readelf.c:7016
+#: ../src/readelf.c:6431
+#: ../src/readelf.c:7009
 #, c-format
 msgid "cannot convert core note data: %s"
 msgstr ""
 
-#: ../src/readelf.c:6743
+#: ../src/readelf.c:6736
 #, fuzzy, c-format
 msgid ""
 "\n"
 "%*s... <repeats %u more times> ..."
 msgstr "Mostrar horas del d√≠a."
 
-#: ../src/readelf.c:6785
+#: ../src/readelf.c:6778
 #, fuzzy, c-format
 msgid "unable to handle register number %d"
 msgstr "No se puede asignar un n√∫mero de partici√≥n."
 
-#: ../src/readelf.c:6932
-#, fuzzy, c-format
-msgid "cannot get register info: %s"
-msgstr "No se pudo registrar el servicio"
-
-#: ../src/readelf.c:6956
+#: ../src/readelf.c:6925
+#: ../src/readelf.c:6949
 #, fuzzy, c-format
 msgid "cannot register info: %s"
 msgstr "No se pudo registrar el servicio"
 
-#: ../src/readelf.c:7114
+#: ../src/readelf.c:7107
 #, fuzzy
 msgid "  Owner          Data size  Type\n"
 msgstr "Escribir un tama√±o en puntos."
 
-#: ../src/readelf.c:7132
+#: ../src/readelf.c:7125
 #, fuzzy, c-format
 msgid "  %-13.*s  %9<PRId32>  %s\n"
 msgstr "13 lugares"
 
-#: ../src/readelf.c:7163
+#: ../src/readelf.c:7156
 #, fuzzy, c-format
 msgid "cannot get content of note section: %s"
 msgstr "%C: No se puede obtener el contenido de la secci√≥n - excepci√≥n de auto-importaci√≥n\n"
 
-#: ../src/readelf.c:7190
+#: ../src/readelf.c:7183
 #, c-format
 msgid ""
 "\n"
 "Note section [%2zu] '%s' of %<PRIu64> bytes at offset %#0<PRIx64>:\n"
 msgstr ""
 
-#: ../src/readelf.c:7213
+#: ../src/readelf.c:7206
 #, c-format
 msgid ""
 "\n"
 "Note segment of %<PRIu64> bytes at offset %#0<PRIx64>:\n"
 msgstr ""
 
-#: ../src/readelf.c:7259
+#: ../src/readelf.c:7252
 #, c-format
 msgid ""
 "\n"
 "Section [%Zu] '%s' has no data to dump.\n"
 msgstr ""
 
-#: ../src/readelf.c:7265
-#: ../src/readelf.c:7287
+#: ../src/readelf.c:7258
+#: ../src/readelf.c:7280
 #, c-format
 msgid "cannot get data for section [%Zu] '%s': %s"
 msgstr ""
 
-#: ../src/readelf.c:7269
+#: ../src/readelf.c:7262
 #, c-format
 msgid ""
 "\n"
 "Hex dump of section [%Zu] '%s', %<PRIu64> bytes at offset %#0<PRIx64>:\n"
 msgstr ""
 
-#: ../src/readelf.c:7282
+#: ../src/readelf.c:7275
 #, fuzzy, c-format
 msgid ""
 "\n"
 "Section [%Zu] '%s' is empty.\n"
 msgstr " La historia de √≥rdenes est√° vac√≠a "
 
-#: ../src/readelf.c:7291
+#: ../src/readelf.c:7284
 #, c-format
 msgid ""
 "\n"
 "String section [%Zu] '%s' contains %<PRIu64> bytes at offset %#0<PRIx64>:\n"
 msgstr ""
 
-#: ../src/readelf.c:7338
+#: ../src/readelf.c:7331
 #, fuzzy, c-format
 msgid ""
 "\n"
 "section [%lu] does not exist"
 msgstr "El anclaje HTML %s no existe."
 
-#: ../src/readelf.c:7364
+#: ../src/readelf.c:7357
 #, fuzzy, c-format
 msgid ""
 "\n"
 "section '%s' does not exist"
 msgstr ": ¬°el archivo no existe!"
 
-#: ../src/readelf.c:7425
+#: ../src/readelf.c:7418
 #, fuzzy, c-format
 msgid "cannot get symbol index of archive '%s': %s"
 msgstr "%s: no se pueden obtener las direcciones del archivo"
 
-#: ../src/readelf.c:7428
+#: ../src/readelf.c:7421
 #, fuzzy, c-format
 msgid ""
 "\n"
 "Archive '%s' has no symbol index\n"
 msgstr "la directiva .ent no tiene s√≠mbolo"
 
-#: ../src/readelf.c:7432
+#: ../src/readelf.c:7425
 #, c-format
 msgid ""
 "\n"
 "Index of archive '%s' has %Zu entries:\n"
 msgstr ""
 
-#: ../src/readelf.c:7450
+#: ../src/readelf.c:7443
 #, c-format
 msgid "cannot extract member at offset %Zu in '%s': %s"
 msgstr ""
 
-#: ../src/readelf.c:7455
+#: ../src/readelf.c:7448
 #, fuzzy, c-format
 msgid "Archive member '%s' contains:\n"
 msgstr "Comprueba si el archivador contiene errores"
@@ -2828,68 +2815,68 @@ msgstr "%s: no se puede crear un nuevo f
 msgid "illformed file '%s'"
 msgstr "Error de archivo"
 
-#: ../src/strip.c:868
-#: ../src/strip.c:955
+#: ../src/strip.c:867
+#: ../src/strip.c:954
 #, fuzzy, c-format
 msgid "while generating output file: %s"
 msgstr "error al cerrar el fichero de salida"
 
-#: ../src/strip.c:928
-#: ../src/strip.c:1667
+#: ../src/strip.c:927
+#: ../src/strip.c:1666
 #, fuzzy, c-format
 msgid "%s: error while creating ELF header: %s"
 msgstr "Error al crear el enlace hacia %B."
 
-#: ../src/strip.c:942
+#: ../src/strip.c:941
 #, fuzzy, c-format
 msgid "while preparing output for '%s'"
 msgstr "no se puede abrir `%s' para salida: %s"
 
-#: ../src/strip.c:993
-#: ../src/strip.c:1049
+#: ../src/strip.c:992
+#: ../src/strip.c:1048
 #, fuzzy, c-format
 msgid "while create section header section: %s"
 msgstr "no se puede crear el encabezado precompilado %s: %m"
 
-#: ../src/strip.c:999
+#: ../src/strip.c:998
 #, fuzzy, c-format
 msgid "cannot allocate section data: %s"
 msgstr "no se puede asignar espacio para los datos del s√≠mbolo"
 
-#: ../src/strip.c:1058
+#: ../src/strip.c:1057
 #, fuzzy, c-format
 msgid "while create section header string table: %s"
 msgstr "fall√≥ la asignaci√≥n de la tabla de cadenas de cabeceras de secci√≥n"
 
-#: ../src/strip.c:1592
-#: ../src/strip.c:1689
+#: ../src/strip.c:1591
+#: ../src/strip.c:1688
 #, fuzzy, c-format
 msgid "while writing '%s': %s"
 msgstr "%s: al escribir el resultado %s: %m:"
 
-#: ../src/strip.c:1603
+#: ../src/strip.c:1602
 #, fuzzy, c-format
 msgid "while creating '%s'"
 msgstr "Error al crear thread"
 
-#: ../src/strip.c:1615
+#: ../src/strip.c:1614
 #, c-format
 msgid "while computing checksum for debug information"
 msgstr ""
 
-#: ../src/strip.c:1675
+#: ../src/strip.c:1674
 #, fuzzy, c-format
 msgid "%s: error while reading the file: %s"
 msgstr "Error al leer archivo."
 
-#: ../src/strip.c:1721
-#: ../src/strip.c:1728
+#: ../src/strip.c:1720
+#: ../src/strip.c:1727
 #, fuzzy, c-format
 msgid "error while finishing '%s': %s"
 msgstr "Error al copiar ¬´%B¬ª."
 
-#: ../src/strip.c:1751
-#: ../src/strip.c:1808
+#: ../src/strip.c:1750
+#: ../src/strip.c:1807
 #, c-format
 msgid "cannot set access and modification date of '%s'"
 msgstr ""
@@ -5184,37 +5171,33 @@ msgstr "Mostrar los nombres de las √°rea
 msgid "Also show symbol or section names"
 msgstr ""
 
-#: ../src/addr2line.c:73
-msgid "Treat addresses as offsets relative to NAME section."
-msgstr ""
-
 #. Short description of program.
-#: ../src/addr2line.c:84
+#: ../src/addr2line.c:82
 msgid "Locate source files and line information for ADDRs (in a.out by default)."
 msgstr ""
 
 #. Strings for arguments in help texts.
-#: ../src/addr2line.c:88
+#: ../src/addr2line.c:86
 #, fuzzy
 msgid "[ADDR...]"
 msgstr " Dir: "
 
-#: ../src/addr2line.c:405
+#: ../src/addr2line.c:387
 #, c-format
 msgid "Section syntax requires exactly one module"
 msgstr ""
 
-#: ../src/addr2line.c:428
+#: ../src/addr2line.c:410
 #, c-format
 msgid "offset %#<PRIxMAX> lies outside section '%s'"
 msgstr ""
 
-#: ../src/addr2line.c:461
+#: ../src/addr2line.c:428
 #, fuzzy, c-format
 msgid "cannot find symbol '%s'"
 msgstr "no se puede encontrar el preprocesador de C: %s \n"
 
-#: ../src/addr2line.c:466
+#: ../src/addr2line.c:433
 #, c-format
 msgid "offset %#<PRIxMAX> lies outside contents of '%s'"
 msgstr ""
--- elfutils/src/ChangeLog
+++ elfutils/src/ChangeLog
@@ -1376,6 +1376,16 @@
 	object symbols or symbols with unknown type.
 	(check_rel): Likewise.
 
+2005-06-09  Roland McGrath  <roland@redhat.com>
+
+	* readelf.c (handle_dynamic, handle_symtab): Check for bogus sh_link.
+	(handle_verneed, handle_verdef, handle_versym, handle_hash): Likewise.
+	(handle_scngrp): Check for bogus sh_info.
+
+	* strip.c (handle_elf): Check for bogus values in sh_link, sh_info,
+	st_shndx, e_shstrndx, and SHT_GROUP or SHT_SYMTAB_SHNDX data.
+	Don't use assert on input values, instead bail with "illformed" error.
+
 2005-06-08  Roland McGrath  <roland@redhat.com>
 
 	* readelf.c (print_ops): Add consts.
@@ -1421,6 +1431,19 @@
 
 	* readelf.c (dwarf_tag_string): Add new tags.
 
+2005-05-17  Jakub Jelinek  <jakub@redhat.com>
+
+	* elflint.c (check_hash): Don't check entries beyond end of section.
+	(check_note): Don't crash if gelf_rawchunk fails.
+	(section_name): Return <invalid> if gelf_getshdr returns NULL.
+
+2005-05-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* elflint.c (section_name): Return "<invalid>" instead of
+	crashing on invalid section name.
+	(check_symtab, is_rel_dyn, check_rela, check_rel, check_dynamic,
+	check_symtab_shndx, check_hash, check_versym): Robustify.
+
 2005-05-08  Roland McGrath  <roland@redhat.com>
 
 	* strip.c (handle_elf): Don't translate hash and versym data formats,
--- elfutils/src/elflint.c
+++ elfutils/src/elflint.c
@@ -130,6 +130,9 @@ static uint32_t shstrndx;
 /* Array to count references in section groups.  */
 static int *scnref;
 
+/* Number of sections.  */
+static unsigned int shnum;
+
 
 int
 main (int argc, char *argv[])
@@ -318,10 +321,19 @@ section_name (Ebl *ebl, int idx)
 {
   GElf_Shdr shdr_mem;
   GElf_Shdr *shdr;
+  const char *ret;
+
+  if ((unsigned int) idx > shnum)
+    return "<invalid>";
 
   shdr = gelf_getshdr (elf_getscn (ebl->elf, idx), &shdr_mem);
+  if (shdr == NULL)
+    return "<invalid>";
 
-  return elf_strptr (ebl->elf, shstrndx, shdr->sh_name);
+  ret = elf_strptr (ebl->elf, shstrndx, shdr->sh_name);
+  if (ret == NULL)
+    return "<invalid>";
+  return ret;
 }
 
 
@@ -343,10 +355,6 @@ static const int valid_e_machine[] =
   (sizeof (valid_e_machine) / sizeof (valid_e_machine[0]))
 
 
-/* Number of sections.  */
-static unsigned int shnum;
-
-
 static void
 check_elf_header (Ebl *ebl, GElf_Ehdr *ehdr, size_t size)
 {
@@ -611,7 +619,8 @@ section [%2d] '%s': symbol table cannot 
 	  }
       }
 
-  if (shdr->sh_entsize != gelf_fsize (ebl->elf, ELF_T_SYM, 1, EV_CURRENT))
+  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_SYM, 1, EV_CURRENT);
+  if (shdr->sh_entsize != sh_entsize)
     ERROR (gettext ("\
 section [%2u] '%s': entry size is does not match ElfXX_Sym\n"),
 	   idx, section_name (ebl, idx));
@@ -649,7 +658,7 @@ section [%2d] '%s': XINDEX for zeroth en
 	       xndxscnidx, section_name (ebl, xndxscnidx));
     }
 
-  for (size_t cnt = 1; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
+  for (size_t cnt = 1; cnt < shdr->sh_size / sh_entsize; ++cnt)
     {
       sym = gelf_getsymshndx (data, xndxdata, cnt, &sym_mem, &xndx);
       if (sym == NULL)
@@ -669,7 +678,8 @@ section [%2d] '%s': symbol %zu: invalid 
       else
 	{
 	  name = elf_strptr (ebl->elf, shdr->sh_link, sym->st_name);
-	  assert (name != NULL);
+	  assert (name != NULL
+		  || strshdr->sh_type != SHT_STRTAB);
 	}
 
       if (sym->st_shndx == SHN_XINDEX)
@@ -999,9 +1009,11 @@ is_rel_dyn (Ebl *ebl, const GElf_Ehdr *e
     {
       GElf_Shdr rcshdr_mem;
       const GElf_Shdr *rcshdr = gelf_getshdr (scn, &rcshdr_mem);
-      assert (rcshdr != NULL);
 
-      if (rcshdr->sh_type == SHT_DYNAMIC)
+      if (rcshdr == NULL)
+	break;
+
+      if (rcshdr->sh_type == SHT_DYNAMIC && rcshdr->sh_entsize)
 	{
 	  /* Found the dynamic section.  Look through it.  */
 	  Elf_Data *d = elf_getdata (scn, NULL);
@@ -1011,7 +1023,9 @@ is_rel_dyn (Ebl *ebl, const GElf_Ehdr *e
 	    {
 	      GElf_Dyn dyn_mem;
 	      GElf_Dyn *dyn = gelf_getdyn (d, cnt, &dyn_mem);
-	      assert (dyn != NULL);
+
+	      if (dyn == NULL)
+		break;
 
 	      if (dyn->d_tag == DT_RELCOUNT)
 		{
@@ -1025,7 +1039,9 @@ section [%2d] '%s': DT_RELCOUNT used for
 		      /* Does the number specified number of relative
 			 relocations exceed the total number of
 			 relocations?  */
-		      if (dyn->d_un.d_val > shdr->sh_size / shdr->sh_entsize)
+		      if (shdr->sh_entsize != 0
+			  && dyn->d_un.d_val > (shdr->sh_size
+						/ shdr->sh_entsize))
 			ERROR (gettext ("\
 section [%2d] '%s': DT_RELCOUNT value %d too high for this section\n"),
 			       idx, section_name (ebl, idx),
@@ -1185,7 +1201,8 @@ section [%2d] '%s': no relocations for m
 	}
     }
 
-  if (shdr->sh_entsize != gelf_fsize (ebl->elf, reltype, 1, EV_CURRENT))
+  size_t sh_entsize = gelf_fsize (ebl->elf, reltype, 1, EV_CURRENT);
+  if (shdr->sh_entsize != sh_entsize)
     ERROR (gettext (reltype == ELF_T_RELA ? "\
 section [%2d] '%s': section entry size does not match ElfXX_Rela\n" : "\
 section [%2d] '%s': section entry size does not match ElfXX_Rel\n"),
@@ -1408,7 +1425,8 @@ check_rela (Ebl *ebl, GElf_Ehdr *ehdr, G
   Elf_Data *symdata = elf_getdata (symscn, NULL);
   enum load_state state = state_undecided;
 
-  for (size_t cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
+  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_RELA, 1, EV_CURRENT);
+  for (size_t cnt = 0; cnt < shdr->sh_size / sh_entsize; ++cnt)
     {
       GElf_Rela rela_mem;
       GElf_Rela *rela = gelf_getrela (data, cnt, &rela_mem);
@@ -1458,7 +1476,8 @@ check_rel (Ebl *ebl, GElf_Ehdr *ehdr, GE
   Elf_Data *symdata = elf_getdata (symscn, NULL);
   enum load_state state = state_undecided;
 
-  for (size_t cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
+  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_REL, 1, EV_CURRENT);
+  for (size_t cnt = 0; cnt < shdr->sh_size / sh_entsize; ++cnt)
     {
       GElf_Rel rel_mem;
       GElf_Rel *rel = gelf_getrel (data, cnt, &rel_mem);
@@ -1561,7 +1580,8 @@ section [%2d] '%s': referenced as string
 	   shdr->sh_link, section_name (ebl, shdr->sh_link),
 	   idx, section_name (ebl, idx));
 
-  if (shdr->sh_entsize != gelf_fsize (ebl->elf, ELF_T_DYN, 1, EV_CURRENT))
+  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_DYN, 1, EV_CURRENT);
+  if (shdr->sh_entsize != sh_entsize)
     ERROR (gettext ("\
 section [%2d] '%s': section entry size does not match ElfXX_Dyn\n"),
 	   idx, section_name (ebl, idx));
@@ -1571,7 +1591,7 @@ section [%2d] '%s': section entry size d
 	   idx, section_name (ebl, idx));
 
   bool non_null_warned = false;
-  for (cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
+  for (cnt = 0; cnt < shdr->sh_size / sh_entsize; ++cnt)
     {
       GElf_Dyn dyn_mem;
       GElf_Dyn *dyn = gelf_getdyn (data, cnt, &dyn_mem);
@@ -1852,6 +1872,8 @@ section [%2d] '%s': entry size does not 
 	   idx, section_name (ebl, idx));
 
   if (symshdr != NULL
+      && shdr->sh_entsize
+      && symshdr->sh_entsize
       && (shdr->sh_size / shdr->sh_entsize
 	  < symshdr->sh_size / symshdr->sh_entsize))
     ERROR (gettext ("\
@@ -1878,6 +1900,12 @@ section [%2d] '%s': extended section ind
     }
 
   Elf_Data *data = elf_getdata (elf_getscn (ebl->elf, idx), NULL);
+  if (data == NULL)
+    {
+      ERROR (gettext ("section [%2d] '%s': cannot get section data\n"),
+ 	     idx, section_name (ebl, idx));
+      return;
+    }
 
   if (*((Elf32_Word *) data->d_buf) != 0)
     ERROR (gettext ("symbol 0 should have zero extended section index\n"));
@@ -1920,7 +1948,7 @@ section [%2d] '%s': hash table section i
 
   size_t maxidx = nchain;
 
-  if (symshdr != NULL)
+  if (symshdr != NULL && symshdr->sh_entsize != 0)
     {
       size_t symsize = symshdr->sh_size / symshdr->sh_entsize;
 
@@ -1931,18 +1959,28 @@ section [%2d] '%s': hash table section i
       maxidx = symsize;
     }
 
+  Elf32_Word *buf = (Elf32_Word *) data->d_buf;
+  Elf32_Word *end = (Elf32_Word *) ((char *) data->d_buf + shdr->sh_size);
   size_t cnt;
   for (cnt = 2; cnt < 2 + nbucket; ++cnt)
-    if (((Elf32_Word *) data->d_buf)[cnt] >= maxidx)
+    {
+      if (buf + cnt >= end)
+	break;
+      else if (buf[cnt] >= maxidx)
       ERROR (gettext ("\
 section [%2d] '%s': hash bucket reference %zu out of bounds\n"),
 	     idx, section_name (ebl, idx), cnt - 2);
+    }
 
   for (; cnt < 2 + nbucket + nchain; ++cnt)
-    if (((Elf32_Word *) data->d_buf)[cnt] >= maxidx)
+    {
+      if (buf + cnt >= end)
+	break;
+      else if (buf[cnt] >= maxidx)
       ERROR (gettext ("\
 section [%2d] '%s': hash chain reference %zu out of bounds\n"),
 	     idx, section_name (ebl, idx), cnt - 2 - nbucket);
+    }
 }
 
 
@@ -1972,18 +2010,28 @@ section [%2d] '%s': hash table section i
       maxidx = symsize;
     }
 
+  Elf64_Xword *buf = (Elf64_Xword *) data->d_buf;
+  Elf64_Xword *end = (Elf64_Xword *) ((char *) data->d_buf + shdr->sh_size);
   size_t cnt;
   for (cnt = 2; cnt < 2 + nbucket; ++cnt)
-    if (((Elf64_Xword *) data->d_buf)[cnt] >= maxidx)
+    {
+      if (buf + cnt >= end)
+	break;
+      else if (buf[cnt] >= maxidx)
       ERROR (gettext ("\
 section [%2d] '%s': hash bucket reference %zu out of bounds\n"),
 	     idx, section_name (ebl, idx), cnt - 2);
+    }
 
   for (; cnt < 2 + nbucket + nchain; ++cnt)
-    if (((Elf64_Xword *) data->d_buf)[cnt] >= maxidx)
+    {
+      if (buf + cnt >= end)
+	break;
+      else if (buf[cnt] >= maxidx)
       ERROR (gettext ("\
 section [%2d] '%s': hash chain reference %" PRIu64 " out of bounds\n"),
-	     idx, section_name (ebl, idx), (uint64_t) (cnt - 2 - nbucket));
+	       idx, section_name (ebl, idx), (uint64_t) cnt - 2 - nbucket);
+    }
 }
 
 
@@ -2008,7 +2056,7 @@ section [%2d] '%s': bitmask size not pow
   if (shdr->sh_size < (4 + bitmask_words + nbuckets) * sizeof (Elf32_Word))
     {
       ERROR (gettext ("\
-section [%2d] '%s': hash table section is too small (is %ld, expected at least%ld)\n"),
+section [%2d] '%s': hash table section is too small (is %ld, expected at least %ld)\n"),
 	     idx, section_name (ebl, idx), (long int) shdr->sh_size,
 	     (long int) ((4 + bitmask_words + nbuckets) * sizeof (Elf32_Word)));
       return;
@@ -2680,8 +2728,9 @@ section [%2d] '%s' refers in sh_link to 
 
   /* The number of elements in the version symbol table must be the
      same as the number of symbols.  */
-  if (shdr->sh_size / shdr->sh_entsize
-      != symshdr->sh_size / symshdr->sh_entsize)
+  if (shdr->sh_entsize && symshdr->sh_entsize
+      && (shdr->sh_size / shdr->sh_entsize
+	  != symshdr->sh_size / symshdr->sh_entsize))
     ERROR (gettext ("\
 section [%2d] '%s' has different number of entries than symbol table [%2d] '%s'\n"),
 	   idx, section_name (ebl, idx),
--- elfutils/src/readelf.c
+++ elfutils/src/readelf.c
@@ -1136,6 +1136,8 @@ handle_scngrp (Ebl *ebl, Elf_Scn *scn, G
   Elf32_Word *grpref = (Elf32_Word *) data->d_buf;
 
   GElf_Sym sym_mem;
+  GElf_Sym *sym = gelf_getsym (symdata, shdr->sh_info, &sym_mem);
+
   printf ((grpref[0] & GRP_COMDAT)
 	  ? ngettext ("\
 \nCOMDAT section group [%2zu] '%s' with signature '%s' contains %zu entry:\n",
@@ -1148,8 +1150,8 @@ handle_scngrp (Ebl *ebl, Elf_Scn *scn, G
 		      data->d_size / sizeof (Elf32_Word) - 1),
 	  elf_ndxscn (scn),
 	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	  elf_strptr (ebl->elf, symshdr->sh_link,
-		      gelf_getsym (symdata, shdr->sh_info, &sym_mem)->st_name)
+	  (sym == NULL ? NULL
+	   : elf_strptr (ebl->elf, symshdr->sh_link, sym->st_name))
 	  ?: gettext ("<INVALID SYMBOL>"),
 	  data->d_size / sizeof (Elf32_Word) - 1);
 
@@ -1300,7 +1302,8 @@ static void
 handle_dynamic (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr)
 {
   int class = gelf_getclass (ebl->elf);
-  GElf_Shdr glink;
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink;
   Elf_Data *data;
   size_t cnt;
   size_t shstrndx;
@@ -1315,6 +1318,11 @@ handle_dynamic (Ebl *ebl, Elf_Scn *scn, 
     error (EXIT_FAILURE, 0,
 	   gettext ("cannot get section header string table index"));
 
+  glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link), &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   printf (ngettext ("\
 \nDynamic segment contains %lu entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
 		    "\
@@ -1324,9 +1332,7 @@ handle_dynamic (Ebl *ebl, Elf_Scn *scn, 
 	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
 	  shdr->sh_offset,
 	  (int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
   fputs_unlocked (gettext ("  Type              Value\n"), stdout);
 
   for (cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
@@ -1826,6 +1832,13 @@ handle_symtab (Ebl *ebl, Elf_Scn *scn, G
     error (EXIT_FAILURE, 0,
 	   gettext ("cannot get section header string table index"));
 
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   /* Now we can compute the number of entries in the section.  */
   unsigned int nsyms = data->d_size / (class == ELFCLASS32
 				       ? sizeof (Elf32_Sym)
@@ -1836,15 +1849,12 @@ handle_symtab (Ebl *ebl, Elf_Scn *scn, G
 		    nsyms),
 	  (unsigned int) elf_ndxscn (scn),
 	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name), nsyms);
-  GElf_Shdr glink;
   printf (ngettext (" %lu local symbol  String table: [%2u] '%s'\n",
 		    " %lu local symbols  String table: [%2u] '%s'\n",
 		    shdr->sh_info),
 	  (unsigned long int) shdr->sh_info,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   fputs_unlocked (class == ELFCLASS32
 		  ? gettext ("\
@@ -2080,7 +2090,13 @@ handle_verneed (Ebl *ebl, Elf_Scn *scn, 
     error (EXIT_FAILURE, 0,
 	   gettext ("cannot get section header string table index"));
 
-  GElf_Shdr glink;
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   printf (ngettext ("\
 \nVersion needs section [%2u] '%s' contains %d entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
 		    "\
@@ -2091,9 +2107,7 @@ handle_verneed (Ebl *ebl, Elf_Scn *scn, 
 	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
 	  shdr->sh_offset,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   unsigned int offset = 0;
   for (int cnt = shdr->sh_info; --cnt >= 0; )
@@ -2146,8 +2160,14 @@ handle_verdef (Ebl *ebl, Elf_Scn *scn, G
     error (EXIT_FAILURE, 0,
 	   gettext ("cannot get section header string table index"));
 
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   int class = gelf_getclass (ebl->elf);
-  GElf_Shdr glink;
   printf (ngettext ("\
 \nVersion definition section [%2u] '%s' contains %d entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
 		    "\
@@ -2159,9 +2179,7 @@ handle_verdef (Ebl *ebl, Elf_Scn *scn, G
 	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
 	  shdr->sh_offset,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   unsigned int offset = 0;
   for (int cnt = shdr->sh_info; --cnt >= 0; )
@@ -2423,8 +2441,14 @@ handle_versym (Ebl *ebl, Elf_Scn *scn, G
       filename = NULL;
     }
 
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   /* Print the header.  */
-  GElf_Shdr glink;
   printf (ngettext ("\
 \nVersion symbols section [%2u] '%s' contains %d entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'",
 		    "\
@@ -2436,9 +2460,7 @@ handle_versym (Ebl *ebl, Elf_Scn *scn, G
 	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
 	  shdr->sh_offset,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   /* Now we can finally look at the actual contents of this section.  */
   for (unsigned int cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
@@ -2490,7 +2512,17 @@ print_hash_info (Ebl *ebl, Elf_Scn *scn,
   for (Elf32_Word cnt = 0; cnt < nbucket; ++cnt)
     ++counts[lengths[cnt]];
 
-  GElf_Shdr glink;
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf,
+					       shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    {
+      error (0, 0, gettext ("invalid sh_link value in section %Zu"),
+	     elf_ndxscn (scn));
+      return;
+    }
+
   printf (ngettext ("\
 \nHistogram for bucket list length in section [%2u] '%s' (total of %d bucket):\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
 		    "\
@@ -2503,9 +2535,7 @@ print_hash_info (Ebl *ebl, Elf_Scn *scn,
 	  shdr->sh_addr,
 	  shdr->sh_offset,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   if (extrastr != NULL)
     fputs (extrastr, stdout);
@@ -4107,6 +4137,16 @@ print_debug_aranges_section (Dwfl_Module
       return;
     }
 
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink;
+  glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link), &glink_mem);
+  if (glink == NULL)
+    {
+      error (0, 0, gettext ("invalid sh_link value in section %Zu"),
+	     elf_ndxscn (scn));
+      return;
+    }
+
   printf (ngettext ("\
 \nDWARF section [%2zu] '%s' at offset %#" PRIx64 " contains %zu entry:\n",
 		    "\
--- elfutils/src/strip.c
+++ elfutils/src/strip.c
@@ -544,6 +544,11 @@ handle_elf (int fd, Elf *elf, const char
       goto fail_close;
     }
 
+  if (shstrndx >= shnum)
+    goto illformed;
+
+#define elf_assert(test) do { if (!(test)) goto illformed; } while (0)
+
   /* Storage for section information.  We leave room for two more
      entries since we unconditionally create a section header string
      table.  Maybe some weird tool created an ELF file without one.
@@ -565,7 +570,7 @@ handle_elf (int fd, Elf *elf, const char
     {
       /* This should always be true (i.e., there should not be any
 	 holes in the numbering).  */
-      assert (elf_ndxscn (scn) == cnt);
+      elf_assert (elf_ndxscn (scn) == cnt);
 
       shdr_info[cnt].scn = scn;
 
@@ -578,6 +583,7 @@ handle_elf (int fd, Elf *elf, const char
 					shdr_info[cnt].shdr.sh_name);
       if (shdr_info[cnt].name == NULL)
 	{
+	illformed:
 	  error (0, 0, gettext ("illformed file '%s'"), fname);
 	  goto fail_close;
 	}
@@ -587,6 +593,8 @@ handle_elf (int fd, Elf *elf, const char
 
       /* Remember the shdr.sh_link value.  */
       shdr_info[cnt].old_sh_link = shdr_info[cnt].shdr.sh_link;
+      if (shdr_info[cnt].old_sh_link >= shnum)
+	goto illformed;
 
       /* Sections in files other than relocatable object files which
 	 are not loaded can be freely moved by us.  In relocatable
@@ -599,7 +607,7 @@ handle_elf (int fd, Elf *elf, const char
 	 appropriate reference.  */
       if (unlikely (shdr_info[cnt].shdr.sh_type == SHT_SYMTAB_SHNDX))
 	{
-	  assert (shdr_info[shdr_info[cnt].shdr.sh_link].symtab_idx == 0);
+	  elf_assert (shdr_info[shdr_info[cnt].shdr.sh_link].symtab_idx == 0);
 	  shdr_info[shdr_info[cnt].shdr.sh_link].symtab_idx = cnt;
 	}
       else if (unlikely (shdr_info[cnt].shdr.sh_type == SHT_GROUP))
@@ -616,7 +624,12 @@ handle_elf (int fd, Elf *elf, const char
 	  for (inner = 1;
 	       inner < shdr_info[cnt].data->d_size / sizeof (Elf32_Word);
 	       ++inner)
+	    {
+	      if (grpref[inner] < shnum)
 	    shdr_info[grpref[inner]].group_idx = cnt;
+	      else
+		goto illformed;
+	    }
 
 	  if (inner == 1 || (inner == 2 && (grpref[0] & GRP_COMDAT) == 0))
 	    /* If the section group contains only one element and this
@@ -627,7 +640,7 @@ handle_elf (int fd, Elf *elf, const char
 	}
       else if (unlikely (shdr_info[cnt].shdr.sh_type == SHT_GNU_versym))
 	{
-	  assert (shdr_info[shdr_info[cnt].shdr.sh_link].version_idx == 0);
+	  elf_assert (shdr_info[shdr_info[cnt].shdr.sh_link].version_idx == 0);
 	  shdr_info[shdr_info[cnt].shdr.sh_link].version_idx = cnt;
 	}
 
@@ -635,7 +648,7 @@ handle_elf (int fd, Elf *elf, const char
 	 discarded right away.  */
       if ((shdr_info[cnt].shdr.sh_flags & SHF_GROUP) != 0)
 	{
-	  assert (shdr_info[cnt].group_idx != 0);
+	  elf_assert (shdr_info[cnt].group_idx != 0);
 
 	  if (shdr_info[shdr_info[cnt].group_idx].idx == 0)
 	    {
@@ -710,11 +723,15 @@ handle_elf (int fd, Elf *elf, const char
 	    {
 	      /* If a relocation section is marked as being removed make
 		 sure the section it is relocating is removed, too.  */
-	      if ((shdr_info[cnt].shdr.sh_type == SHT_REL
+	      if (shdr_info[cnt].shdr.sh_type == SHT_REL
 		   || shdr_info[cnt].shdr.sh_type == SHT_RELA)
-		  && shdr_info[shdr_info[cnt].shdr.sh_info].idx != 0)
+		{
+		  if (shdr_info[cnt].shdr.sh_info >= shnum)
+		    goto illformed;
+		  else if (shdr_info[shdr_info[cnt].shdr.sh_info].idx != 0)
 		shdr_info[cnt].idx = 1;
 	    }
+	    }
 
 	  if (shdr_info[cnt].idx == 1)
 	    {
@@ -741,7 +758,7 @@ handle_elf (int fd, Elf *elf, const char
 		  if (shdr_info[cnt].symtab_idx != 0
 		      && shdr_info[shdr_info[cnt].symtab_idx].data == NULL)
 		    {
-		      assert (shdr_info[cnt].shdr.sh_type == SHT_SYMTAB);
+		      elf_assert (shdr_info[cnt].shdr.sh_type == SHT_SYMTAB);
 
 		      shdr_info[shdr_info[cnt].symtab_idx].data
 			= elf_getdata (shdr_info[shdr_info[cnt].symtab_idx].scn,
@@ -781,6 +798,9 @@ handle_elf (int fd, Elf *elf, const char
 		      else if (scnidx == SHN_XINDEX)
 			scnidx = xndx;
 
+		      if (scnidx >= shnum)
+			goto illformed;
+
 		      if (shdr_info[scnidx].idx == 0)
 			/* This symbol table has a real symbol in
 			   a discarded section.  So preserve the
@@ -811,12 +831,16 @@ handle_elf (int fd, Elf *elf, const char
 		}
 
 	      /* Handle references through sh_info.  */
-	      if (SH_INFO_LINK_P (&shdr_info[cnt].shdr)
-		  && shdr_info[shdr_info[cnt].shdr.sh_info].idx == 0)
+	      if (SH_INFO_LINK_P (&shdr_info[cnt].shdr))
+		{
+		  if (shdr_info[cnt].shdr.sh_info >= shnum)
+		    goto illformed;
+		  else if ( shdr_info[shdr_info[cnt].shdr.sh_info].idx == 0)
 		{
 		  shdr_info[shdr_info[cnt].shdr.sh_info].idx = 1;
 		  changes |= shdr_info[cnt].shdr.sh_info < cnt;
 		}
+		}
 
 	      /* Mark the section as investigated.  */
 	      shdr_info[cnt].idx = 2;
@@ -955,7 +979,7 @@ handle_elf (int fd, Elf *elf, const char
 	  error (EXIT_FAILURE, 0, gettext ("while generating output file: %s"),
 		 elf_errmsg (-1));
 
-	assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
+	elf_assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
 
 	/* Add this name to the section header string table.  */
 	shdr_info[cnt].se = ebl_strtabadd (shst, shdr_info[cnt].name, 0);
@@ -992,7 +1016,7 @@ handle_elf (int fd, Elf *elf, const char
 	error (EXIT_FAILURE, 0,
 	       gettext ("while create section header section: %s"),
 	       elf_errmsg (-1));
-      assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
+      elf_assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
 
       shdr_info[cnt].data = elf_newdata (shdr_info[cnt].newscn);
       if (shdr_info[cnt].data == NULL)
@@ -1048,7 +1072,7 @@ handle_elf (int fd, Elf *elf, const char
     error (EXIT_FAILURE, 0,
 	   gettext ("while create section header section: %s"),
 	   elf_errmsg (-1));
-  assert (elf_ndxscn (shdr_info[cnt].newscn) == idx);
+  elf_assert (elf_ndxscn (shdr_info[cnt].newscn) == idx);
 
   /* Finalize the string table and fill in the correct indices in the
      section headers.  */
@@ -1138,20 +1162,20 @@ handle_elf (int fd, Elf *elf, const char
 		    shndxdata = elf_getdata (shdr_info[shdr_info[cnt].symtab_idx].scn,
 					     NULL);
 
-		    assert ((versiondata->d_size / sizeof (Elf32_Word))
+		    elf_assert ((versiondata->d_size / sizeof (Elf32_Word))
 			    >= shdr_info[cnt].data->d_size / elsize);
 		  }
 
 		if (shdr_info[cnt].version_idx != 0)
 		  {
-		    assert (shdr_info[cnt].shdr.sh_type == SHT_DYNSYM);
+		    elf_assert (shdr_info[cnt].shdr.sh_type == SHT_DYNSYM);
 		    /* This section has associated version
 		       information.  We have to modify that
 		       information, too.  */
 		    versiondata = elf_getdata (shdr_info[shdr_info[cnt].version_idx].scn,
 					       NULL);
 
-		    assert ((versiondata->d_size / sizeof (GElf_Versym))
+		    elf_assert ((versiondata->d_size / sizeof (GElf_Versym))
 			    >= shdr_info[cnt].data->d_size / elsize);
 		  }
 
@@ -1206,7 +1230,7 @@ handle_elf (int fd, Elf *elf, const char
 		      sec = shdr_info[sym->st_shndx].idx;
 		    else
 		      {
-			assert (shndxdata != NULL);
+			elf_assert (shndxdata != NULL);
 
 			sec = shdr_info[xshndx].idx;
 		      }
@@ -1227,7 +1251,7 @@ handle_elf (int fd, Elf *elf, const char
 			    nxshndx = sec;
 			  }
 
-			assert (sec < SHN_LORESERVE || shndxdata != NULL);
+			elf_assert (sec < SHN_LORESERVE || shndxdata != NULL);
 
 			if ((inner != destidx || nshndx != sym->st_shndx
 			     || (shndxdata != NULL && nxshndx != xshndx))
@@ -1251,7 +1275,7 @@ handle_elf (int fd, Elf *elf, const char
 			     || shdr_info[cnt].debug_data == NULL)
 		      /* This is a section symbol for a section which has
 			 been removed.  */
-		      assert (GELF_ST_TYPE (sym->st_info) == STT_SECTION);
+		      elf_assert (GELF_ST_TYPE (sym->st_info) == STT_SECTION);
 		  }
 
 		if (destidx != inner)
@@ -1438,11 +1462,11 @@ handle_elf (int fd, Elf *elf, const char
 		  {
 		    GElf_Sym sym_mem;
 		    GElf_Sym *sym = gelf_getsym (symd, inner, &sym_mem);
-		    assert (sym != NULL);
+		    elf_assert (sym != NULL);
 
 		    const char *name = elf_strptr (elf, strshndx,
 						   sym->st_name);
-		    assert (name != NULL);
+		    elf_assert (name != NULL);
 		    size_t hidx = elf_hash (name) % nbucket;
 
 		    if (bucket[hidx] == 0)
@@ -1461,7 +1485,7 @@ handle_elf (int fd, Elf *elf, const char
 	    else
 	      {
 		/* Alpha and S390 64-bit use 64-bit SHT_HASH entries.  */
-		assert (shdr_info[cnt].shdr.sh_entsize
+		elf_assert (shdr_info[cnt].shdr.sh_entsize
 			== sizeof (Elf64_Xword));
 
 		Elf64_Xword *bucket = (Elf64_Xword *) hashd->d_buf;
@@ -1492,11 +1516,11 @@ handle_elf (int fd, Elf *elf, const char
 		  {
 		    GElf_Sym sym_mem;
 		    GElf_Sym *sym = gelf_getsym (symd, inner, &sym_mem);
-		    assert (sym != NULL);
+		    elf_assert (sym != NULL);
 
 		    const char *name = elf_strptr (elf, strshndx,
 						   sym->st_name);
-		    assert (name != NULL);
+		    elf_assert (name != NULL);
 		    size_t hidx = elf_hash (name) % nbucket;
 
 		    if (bucket[hidx] == 0)
