--- elfutils/libelf/ChangeLog
+++ elfutils/libelf/ChangeLog
@@ -529,6 +529,49 @@
 	If section content hasn't been read yet, do it before looking for the
 	block size.  If no section data present, infer size of section header.
 
+2005-05-17  Jakub Jelinek  <jakub@redhat.com>
+
+	* elf32_getphdr.c (elfw2(LIBELFBITS,getphdr)): Check if program header
+	table fits into object's bounds.
+	* elf_getshstrndx.c (elf_getshstrndx): Add elf->start_offset to
+	elf->map_address.  Check if first section header fits into object's
+	bounds.
+	* elf32_getshdr.c (elfw2(LIBELFBITS,getshdr)):
+	Check if section header table fits into object's bounds.
+	* elf_begin.c (get_shnum): Ensure section headers fits into
+	object's bounds.
+	(file_read_elf): Make sure scncnt is small enough to allocate both
+	ElfXX_Shdr and Elf_Scn array.  Make sure section and program header
+	tables fit into object's bounds.  Avoid memory leak on failure.
+
+2005-05-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* libelfP.h (INVALID_NDX): Define.
+	* gelf_getdyn.c (gelf_getdyn): Use it.  Remove ndx < 0 test if any.
+	* gelf_getlib.c (gelf_getlib): Likewise.
+	* gelf_getmove.c (gelf_getmove): Likewise.
+	* gelf_getrel.c (gelf_getrel): Likewise.
+	* gelf_getrela.c (gelf_getrela): Likewise.
+	* gelf_getsym.c (gelf_getsym): Likewise.
+	* gelf_getsyminfo.c (gelf_getsyminfo): Likewise.
+	* gelf_getsymshndx.c (gelf_getsymshndx): Likewise.
+	* gelf_getversym.c (gelf_getversym): Likewise.
+	* gelf_update_dyn.c (gelf_update_dyn): Likewise.
+	* gelf_update_lib.c (gelf_update_lib): Likewise.
+	* gelf_update_move.c (gelf_update_move): Likewise.
+	* gelf_update_rel.c (gelf_update_rel): Likewise.
+	* gelf_update_rela.c (gelf_update_rela): Likewise.
+	* gelf_update_sym.c (gelf_update_sym): Likewise.
+	* gelf_update_syminfo.c (gelf_update_syminfo): Likewise.
+	* gelf_update_symshndx.c (gelf_update_symshndx): Likewise.
+	* gelf_update_versym.c (gelf_update_versym): Likewise.
+	* elf_newscn.c (elf_newscn): Check for overflow.
+	* elf32_updatefile.c (__elfw2(LIBELFBITS,updatemmap)): Likewise.
+	(__elfw2(LIBELFBITS,updatefile)): Likewise.
+	* elf_begin.c (file_read_elf): Likewise.
+	* elf32_newphdr.c (elfw2(LIBELFBITS,newphdr)): Likewise.
+	* elf_getarsym.c (elf_getarsym): Likewise.
+	* elf32_getshdr.c (elfw2(LIBELFBITS,getshdr)): Likewise.
 2005-05-11  Ulrich Drepper  <drepper@redhat.com>
 
 	* elf.h: Update again.
--- elfutils/libelf/elf32_getphdr.c
+++ elfutils/libelf/elf32_getphdr.c
@@ -105,6 +105,16 @@ __elfw2(LIBELFBITS,getphdr_wrlock) (elf)
 
       if (elf->map_address != NULL)
 	{
+	  /* First see whether the information in the ELF header is
+	     valid and it does not ask for too much.  */
+	  if (unlikely (ehdr->e_phoff >= elf->maximum_size)
+	      || unlikely (ehdr->e_phoff + size > elf->maximum_size))
+	    {
+	      /* Something is wrong.  */
+	      __libelf_seterrno (ELF_E_INVALID_PHDR);
+	      goto out;
+	    }
+
 	  /* All the data is already mapped.  Use it.  */
 	  void *file_phdr = ((char *) elf->map_address
 			     + elf->start_offset + ehdr->e_phoff);
--- elfutils/libelf/elf32_getshdr.c
+++ elfutils/libelf/elf32_getshdr.c
@@ -1,5 +1,5 @@
 /* Return section header.
-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2005, 2007 Red Hat, Inc.
+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2005, 2007, 2008 Red Hat, Inc.
    This file is part of Red Hat elfutils.
    Written by Ulrich Drepper <drepper@redhat.com>, 1998.
 
@@ -81,7 +81,8 @@ load_shdr_wrlock (Elf_Scn *scn)
     goto out;
 
   size_t shnum;
-  if (__elf_getshnum_rdlock (elf, &shnum) != 0)
+  if (__elf_getshnum_rdlock (elf, &shnum) != 0
+      || shnum > SIZE_MAX / sizeof (ElfW2(LIBELFBITS,Shdr)))
     goto out;
   size_t size = shnum * sizeof (ElfW2(LIBELFBITS,Shdr));
 
@@ -98,6 +99,16 @@ load_shdr_wrlock (Elf_Scn *scn)
 
   if (elf->map_address != NULL)
     {
+      /* First see whether the information in the ELF header is
+	 valid and it does not ask for too much.  */
+      if (unlikely (ehdr->e_shoff >= elf->maximum_size)
+	  || unlikely (ehdr->e_shoff + size > elf->maximum_size))
+	{
+	  /* Something is wrong.  */
+	  __libelf_seterrno (ELF_E_INVALID_SECTION_HEADER);
+	  goto free_and_out;
+	}
+
       ElfW2(LIBELFBITS,Shdr) *notcvt;
 
       /* All the data is already mapped.  If we could use it
--- elfutils/libelf/elf32_newphdr.c
+++ elfutils/libelf/elf32_newphdr.c
@@ -124,6 +124,12 @@ elfw2(LIBELFBITS,newphdr) (elf, count)
   else if (elf->state.ELFW(elf,LIBELFBITS).ehdr->e_phnum != count
 	   || elf->state.ELFW(elf,LIBELFBITS).phdr == NULL)
     {
+      if (unlikely (count > SIZE_MAX / sizeof (ElfW2(LIBELFBITS,Phdr))))
+	{
+	  result = NULL;
+	  goto out;
+	}
+
       /* Allocate a new program header with the appropriate number of
 	 elements.  */
       result = (ElfW2(LIBELFBITS,Phdr) *)
--- elfutils/libelf/elf32_updatefile.c
+++ elfutils/libelf/elf32_updatefile.c
@@ -220,6 +220,9 @@ __elfw2(LIBELFBITS,updatemmap) (Elf *elf
   /* Write all the sections.  Well, only those which are modified.  */
   if (shnum > 0)
     {
+      if (unlikely (shnum > SIZE_MAX / sizeof (Elf_Scn *)))
+ 	return 1;
+
       Elf_ScnList *list = &elf->state.ELFW(elf,LIBELFBITS).scns;
       Elf_Scn **scns = (Elf_Scn **) alloca (shnum * sizeof (Elf_Scn *));
       char *const shdr_start = ((char *) elf->map_address + elf->start_offset
@@ -633,6 +636,10 @@ __elfw2(LIBELFBITS,updatefile) (Elf *elf
   /* Write all the sections.  Well, only those which are modified.  */
   if (shnum > 0)
     {
+      if (unlikely (shnum > SIZE_MAX / (sizeof (Elf_Scn *)
+					+ sizeof (ElfW2(LIBELFBITS,Shdr)))))
+	return 1;
+
       off_t shdr_offset = elf->start_offset + ehdr->e_shoff;
 #if EV_NUM != 2
       xfct_t shdr_fctp = __elf_xfctstom[__libelf_version - 1][EV_CURRENT - 1][ELFW(ELFCLASS, LIBELFBITS) - 1][ELF_T_SHDR];
--- elfutils/libelf/elf_begin.c
+++ elfutils/libelf/elf_begin.c
@@ -165,7 +165,8 @@ get_shnum (void *map_address, unsigned c
 
       if (unlikely (result == 0) && ehdr.e32->e_shoff != 0)
 	{
-	  if (ehdr.e32->e_shoff + sizeof (Elf32_Shdr) > maxsize)
+	  if (unlikely (ehdr.e32->e_shoff >= maxsize)
+	      || unlikely (ehdr.e32->e_shoff + sizeof (Elf32_Shdr) > maxsize))
 	    /* Cannot read the first section header.  */
 	    return 0;
 
@@ -213,7 +214,8 @@ get_shnum (void *map_address, unsigned c
 
       if (unlikely (result == 0) && ehdr.e64->e_shoff != 0)
 	{
-	  if (ehdr.e64->e_shoff + sizeof (Elf64_Shdr) > maxsize)
+	  if (unlikely (ehdr.e64->e_shoff >= maxsize)
+	      || unlikely (ehdr.e64->e_shoff + sizeof (Elf64_Shdr) > maxsize))
 	    /* Cannot read the first section header.  */
 	    return 0;
 
@@ -285,6 +287,15 @@ file_read_elf (int fildes, void *map_add
     /* Could not determine the number of sections.  */
     return NULL;
 
+  /* Check for too many sections.  */
+  if (e_ident[EI_CLASS] == ELFCLASS32)
+    {
+      if (scncnt > SIZE_MAX / (sizeof (Elf_Scn) + sizeof (Elf32_Shdr)))
+	return NULL;
+    }
+  else if (scncnt > SIZE_MAX / (sizeof (Elf_Scn) + sizeof (Elf64_Shdr)))
+    return NULL;
+
   /* We can now allocate the memory.  */
   Elf *elf = allocate_elf (fildes, map_address, offset, maxsize, cmd, parent,
 			   ELF_K_ELF, scncnt * sizeof (Elf_Scn));
@@ -318,13 +329,31 @@ file_read_elf (int fildes, void *map_add
 	{
 	  /* We can use the mmapped memory.  */
 	  elf->state.elf32.ehdr = ehdr;
+
+	  if (unlikely (ehdr->e_shoff >= maxsize)
+	      || unlikely (ehdr->e_shoff
+			   + scncnt * sizeof (Elf32_Shdr) > maxsize))
+	    {
+	    free_and_out:
+	      free (elf);
+	      __libelf_seterrno (ELF_E_INVALID_FILE);
+	      return NULL;
+	    }
 	  elf->state.elf32.shdr
 	    = (Elf32_Shdr *) ((char *) ehdr + ehdr->e_shoff);
+
 	  if (ehdr->e_phnum > 0)
+	    {
 	    /* Assign a value only if there really is a program
 	       header.  Otherwise the value remains NULL.  */
+	      if (unlikely (ehdr->e_phoff >= maxsize)
+		  || unlikely (ehdr->e_phoff
+			       + ehdr->e_phnum
+			       * sizeof (Elf32_Phdr) > maxsize))
+		goto free_and_out;
 	    elf->state.elf32.phdr
 	      = (Elf32_Phdr *) ((char *) ehdr + ehdr->e_phoff);
+	    }
 
 	  for (size_t cnt = 0; cnt < scncnt; ++cnt)
 	    {
@@ -406,13 +435,26 @@ file_read_elf (int fildes, void *map_add
 	{
 	  /* We can use the mmapped memory.  */
 	  elf->state.elf64.ehdr = ehdr;
+
+	  if (unlikely (ehdr->e_shoff >= maxsize)
+	      || unlikely (ehdr->e_shoff
+			   + scncnt * sizeof (Elf32_Shdr) > maxsize))
+	    goto free_and_out;
 	  elf->state.elf64.shdr
 	    = (Elf64_Shdr *) ((char *) ehdr + ehdr->e_shoff);
+
 	  if (ehdr->e_phnum > 0)
+	    {
 	    /* Assign a value only if there really is a program
 	       header.  Otherwise the value remains NULL.  */
+	      if (unlikely (ehdr->e_phoff >= maxsize)
+		  || unlikely (ehdr->e_phoff
+			       + ehdr->e_phnum
+			       * sizeof (Elf32_Phdr) > maxsize))
+		goto free_and_out;
 	    elf->state.elf64.phdr
 	      = (Elf64_Phdr *) ((char *) ehdr + ehdr->e_phoff);
+	    }
 
 	  for (size_t cnt = 0; cnt < scncnt; ++cnt)
 	    {
--- elfutils/libelf/elf_getarsym.c
+++ elfutils/libelf/elf_getarsym.c
@@ -179,6 +179,9 @@ elf_getarsym (elf, ptr)
       size_t index_size = atol (tmpbuf);
 
       if (SARMAG + sizeof (struct ar_hdr) + index_size > elf->maximum_size
+#if SIZE_MAX <= 4294967295U
+	  || n >= SIZE_MAX / sizeof (Elf_Arsym)
+#endif
 	  || n * sizeof (uint32_t) > index_size)
 	{
 	  /* This index table cannot be right since it does not fit into
--- elfutils/libelf/elf_getshstrndx.c
+++ elfutils/libelf/elf_getshstrndx.c
@@ -125,10 +125,25 @@ elf_getshstrndx (elf, dst)
 	      if (elf->map_address != NULL
 		  && elf->state.elf32.ehdr->e_ident[EI_DATA] == MY_ELFDATA
 		  && (ALLOW_UNALIGNED
-		      || (((size_t) ((char *) elf->map_address + offset))
+		      || (((size_t) ((char *) elf->map_address
+			   + elf->start_offset + offset))
 			  & (__alignof__ (Elf32_Shdr) - 1)) == 0))
+		{
+		  /* First see whether the information in the ELF header is
+		     valid and it does not ask for too much.  */
+		  if (unlikely (offset + sizeof (Elf32_Shdr)
+				> elf->maximum_size))
+		    {
+		      /* Something is wrong.  */
+		      __libelf_seterrno (ELF_E_INVALID_SECTION_HEADER);
+		      result = -1;
+		      goto out;
+		    }
+
 		/* We can directly access the memory.  */
-		num = ((Elf32_Shdr *) (elf->map_address + offset))->sh_link;
+		  num = ((Elf32_Shdr *) (elf->map_address + elf->start_offset
+					 + offset))->sh_link;
+		}
 	      else
 		{
 		  /* We avoid reading in all the section headers.  Just read
@@ -163,10 +178,25 @@ elf_getshstrndx (elf, dst)
 	      if (elf->map_address != NULL
 		  && elf->state.elf64.ehdr->e_ident[EI_DATA] == MY_ELFDATA
 		  && (ALLOW_UNALIGNED
-		      || (((size_t) ((char *) elf->map_address + offset))
+		      || (((size_t) ((char *) elf->map_address
+			   + elf->start_offset + offset))
 			  & (__alignof__ (Elf64_Shdr) - 1)) == 0))
+		{
+		  /* First see whether the information in the ELF header is
+		     valid and it does not ask for too much.  */
+		  if (unlikely (offset + sizeof (Elf64_Shdr)
+				> elf->maximum_size))
+		    {
+		      /* Something is wrong.  */
+		      __libelf_seterrno (ELF_E_INVALID_SECTION_HEADER);
+		      result = -1;
+		      goto out;
+		    }
+
 		/* We can directly access the memory.  */
-		num = ((Elf64_Shdr *) (elf->map_address + offset))->sh_link;
+		  num = ((Elf64_Shdr *) (elf->map_address
+			 + elf->start_offset + offset))->sh_link;
+		}
 	      else
 		{
 		  /* We avoid reading in all the section headers.  Just read
--- elfutils/libelf/elf_newscn.c
+++ elfutils/libelf/elf_newscn.c
@@ -104,10 +104,18 @@ elf_newscn (elf)
   else
     {
       /* We must allocate a new element.  */
-      Elf_ScnList *newp;
+      Elf_ScnList *newp = NULL;
 
       assert (elf->state.elf.scnincr > 0);
 
+      if (
+#if SIZE_MAX <= 4294967295U
+	  likely (elf->state.elf.scnincr
+		  < SIZE_MAX / 2 / sizeof (Elf_Scn) - sizeof (Elf_ScnList))
+#else
+	  1
+#endif
+	  )
       newp = (Elf_ScnList *) calloc (sizeof (Elf_ScnList)
 				     + ((elf->state.elf.scnincr *= 2)
 					* sizeof (Elf_Scn)), 1);
--- elfutils/libelf/gelf_getdyn.c
+++ elfutils/libelf/gelf_getdyn.c
@@ -93,7 +93,8 @@ gelf_getdyn (data, ndx, dst)
 	 table entries has to be adopted.  The user better has provided
 	 a buffer where we can store the information.  While copying the
 	 data we are converting the format.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Dyn) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Dyn)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Dyn) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -114,7 +115,8 @@ gelf_getdyn (data, ndx, dst)
 
       /* The data is already in the correct form.  Just make sure the
 	 index is OK.  */
-      if (unlikely ((ndx + 1) * sizeof (GElf_Dyn) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, GElf_Dyn)
+	  || unlikely ((ndx + 1) * sizeof (GElf_Dyn) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_getlib.c
+++ elfutils/libelf/gelf_getlib.c
@@ -86,7 +86,8 @@ gelf_getlib (data, ndx, dst)
   /* The data is already in the correct form.  Just make sure the
      index is OK.  */
   GElf_Lib *result = NULL;
-  if (unlikely ((ndx + 1) * sizeof (GElf_Lib) > data->d_size))
+  if (INVALID_NDX (ndx, GElf_Lib)
+      || unlikely ((ndx + 1) * sizeof (GElf_Lib) > data->d_size))
     __libelf_seterrno (ELF_E_INVALID_INDEX);
   else
     {
--- elfutils/libelf/gelf_getmove.c
+++ elfutils/libelf/gelf_getmove.c
@@ -83,7 +83,8 @@ gelf_getmove (data, ndx, dst)
 
   /* The data is already in the correct form.  Just make sure the
      index is OK.  */
-  if (unlikely ((ndx + 1) * sizeof (GElf_Move) > data->d_size))
+  if (INVALID_NDX (ndx, GElf_Move)
+      || unlikely ((ndx + 1) * sizeof (GElf_Move) > data->d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
       goto out;
--- elfutils/libelf/gelf_getrela.c
+++ elfutils/libelf/gelf_getrela.c
@@ -71,12 +71,6 @@ gelf_getrela (data, ndx, dst)
   if (data_scn == NULL)
     return NULL;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return NULL;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_RELA))
     {
       __libelf_seterrno (ELF_E_INVALID_HANDLE);
@@ -93,7 +87,8 @@ gelf_getrela (data, ndx, dst)
   if (scn->elf->class == ELFCLASS32)
     {
       /* We have to convert the data.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Rela) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Rela)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Rela) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  result = NULL;
@@ -114,7 +109,8 @@ gelf_getrela (data, ndx, dst)
     {
       /* Simply copy the data after we made sure we are actually getting
 	 correct data.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Rela) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Rela)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Rela) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  result = NULL;
--- elfutils/libelf/gelf_getrel.c
+++ elfutils/libelf/gelf_getrel.c
@@ -71,12 +71,6 @@ gelf_getrel (data, ndx, dst)
   if (data_scn == NULL)
     return NULL;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return NULL;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_REL))
     {
       __libelf_seterrno (ELF_E_INVALID_HANDLE);
@@ -93,7 +87,8 @@ gelf_getrel (data, ndx, dst)
   if (scn->elf->class == ELFCLASS32)
     {
       /* We have to convert the data.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Rel) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Rel)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Rel) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  result = NULL;
@@ -113,7 +108,8 @@ gelf_getrel (data, ndx, dst)
     {
       /* Simply copy the data after we made sure we are actually getting
 	 correct data.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Rel) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Rel)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Rel) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  result = NULL;
--- elfutils/libelf/gelf_getsym.c
+++ elfutils/libelf/gelf_getsym.c
@@ -90,7 +90,8 @@ gelf_getsym (data, ndx, dst)
 	 table entries has to be adopted.  The user better has provided
 	 a buffer where we can store the information.  While copying the
 	 data we are converting the format.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Sym) > data->d_size))
+      if (INVALID_NDX (ndx, Elf32_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Sym) > data->d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -119,7 +120,8 @@ gelf_getsym (data, ndx, dst)
 
       /* The data is already in the correct form.  Just make sure the
 	 index is OK.  */
-      if (unlikely ((ndx + 1) * sizeof (GElf_Sym) > data->d_size))
+      if (INVALID_NDX (ndx, GElf_Sym)
+	  || unlikely ((ndx + 1) * sizeof (GElf_Sym) > data->d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_getsyminfo.c
+++ elfutils/libelf/gelf_getsyminfo.c
@@ -84,7 +84,8 @@ gelf_getsyminfo (data, ndx, dst)
 
   /* The data is already in the correct form.  Just make sure the
      index is OK.  */
-  if (unlikely ((ndx + 1) * sizeof (GElf_Syminfo) > data->d_size))
+  if (INVALID_NDX (ndx, GElf_Syminfo)
+      || unlikely ((ndx + 1) * sizeof (GElf_Syminfo) > data->d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
       goto out;
--- elfutils/libelf/gelf_getsymshndx.c
+++ elfutils/libelf/gelf_getsymshndx.c
@@ -90,7 +90,9 @@ gelf_getsymshndx (symdata, shndxdata, nd
      section index table.  */
   if (likely (shndxdata_scn != NULL))
     {
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Word) > shndxdata_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Word)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Word)
+		       > shndxdata_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -110,7 +112,8 @@ gelf_getsymshndx (symdata, shndxdata, nd
 	 table entries has to be adopted.  The user better has provided
 	 a buffer where we can store the information.  While copying the
 	 data we are converting the format.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Sym) > symdata->d_size))
+      if (INVALID_NDX (ndx, Elf32_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Sym) > symdata->d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -139,7 +142,8 @@ gelf_getsymshndx (symdata, shndxdata, nd
 
       /* The data is already in the correct form.  Just make sure the
 	 index is OK.  */
-      if (unlikely ((ndx + 1) * sizeof (GElf_Sym) > symdata->d_size))
+      if (INVALID_NDX (ndx, GElf_Sym)
+	  || unlikely ((ndx + 1) * sizeof (GElf_Sym) > symdata->d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_getversym.c
+++ elfutils/libelf/gelf_getversym.c
@@ -92,7 +92,8 @@ gelf_getversym (data, ndx, dst)
 
   /* The data is already in the correct form.  Just make sure the
      index is OK.  */
-  if (unlikely ((ndx + 1) * sizeof (GElf_Versym) > data->d_size))
+  if (INVALID_NDX (ndx, GElf_Versym)
+      || unlikely ((ndx + 1) * sizeof (GElf_Versym) > data->d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
       result = NULL;
--- elfutils/libelf/gelf_update_dyn.c
+++ elfutils/libelf/gelf_update_dyn.c
@@ -71,12 +71,6 @@ gelf_update_dyn (data, ndx, src)
   if (data == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_DYN))
     {
       /* The type of the data better should match.  */
@@ -102,7 +96,8 @@ gelf_update_dyn (data, ndx, src)
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Dyn) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Dyn)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Dyn) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -116,7 +111,8 @@ gelf_update_dyn (data, ndx, src)
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Dyn) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Dyn)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Dyn) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_lib.c
+++ elfutils/libelf/gelf_update_lib.c
@@ -68,12 +68,6 @@ gelf_update_lib (data, ndx, src)
   if (data == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   Elf_Data_Scn *data_scn = (Elf_Data_Scn *) data;
   if (unlikely (data_scn->d.d_type != ELF_T_LIB))
     {
@@ -87,7 +81,8 @@ gelf_update_lib (data, ndx, src)
 
   /* Check whether we have to resize the data buffer.  */
   int result = 0;
-  if (unlikely ((ndx + 1) * sizeof (Elf64_Lib) > data_scn->d.d_size))
+  if (INVALID_NDX (ndx, Elf64_Lib)
+      || unlikely ((ndx + 1) * sizeof (Elf64_Lib) > data_scn->d.d_size))
     __libelf_seterrno (ELF_E_INVALID_INDEX);
   else
     {
--- elfutils/libelf/gelf_update_move.c
+++ elfutils/libelf/gelf_update_move.c
@@ -75,7 +75,7 @@ gelf_update_move (data, ndx, src)
   assert (sizeof (GElf_Move) == sizeof (Elf64_Move));
 
   /* Check whether we have to resize the data buffer.  */
-  if (unlikely (ndx < 0)
+  if (INVALID_NDX (ndx, GElf_Move)
       || unlikely ((ndx + 1) * sizeof (GElf_Move) > data_scn->d.d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
--- elfutils/libelf/gelf_update_rela.c
+++ elfutils/libelf/gelf_update_rela.c
@@ -68,12 +68,6 @@ gelf_update_rela (Elf_Data *dst, int ndx
   if (dst == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_RELA))
     {
       /* The type of the data better should match.  */
@@ -101,7 +95,8 @@ gelf_update_rela (Elf_Data *dst, int ndx
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Rela) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Rela)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Rela) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -117,7 +112,8 @@ gelf_update_rela (Elf_Data *dst, int ndx
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Rela) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Rela)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Rela) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_rel.c
+++ elfutils/libelf/gelf_update_rel.c
@@ -68,12 +68,6 @@ gelf_update_rel (Elf_Data *dst, int ndx,
   if (dst == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_REL))
     {
       /* The type of the data better should match.  */
@@ -99,7 +93,8 @@ gelf_update_rel (Elf_Data *dst, int ndx,
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Rel) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Rel)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Rel) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -114,7 +109,8 @@ gelf_update_rel (Elf_Data *dst, int ndx,
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Rel) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Rel)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Rel) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_sym.c
+++ elfutils/libelf/gelf_update_sym.c
@@ -72,12 +72,6 @@ gelf_update_sym (data, ndx, src)
   if (data == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_SYM))
     {
       /* The type of the data better should match.  */
@@ -102,7 +96,8 @@ gelf_update_sym (data, ndx, src)
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Sym) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Sym) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -125,7 +120,8 @@ gelf_update_sym (data, ndx, src)
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Sym) > data_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Sym) > data_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_syminfo.c
+++ elfutils/libelf/gelf_update_syminfo.c
@@ -72,12 +72,6 @@ gelf_update_syminfo (data, ndx, src)
   if (data == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (data_scn->d.d_type != ELF_T_SYMINFO))
     {
       /* The type of the data better should match.  */
@@ -93,7 +87,8 @@ gelf_update_syminfo (data, ndx, src)
   rwlock_wrlock (scn->elf->lock);
 
   /* Check whether we have to resize the data buffer.  */
-  if (unlikely ((ndx + 1) * sizeof (GElf_Syminfo) > data_scn->d.d_size))
+  if (INVALID_NDX (ndx, GElf_Syminfo)
+      || unlikely ((ndx + 1) * sizeof (GElf_Syminfo) > data_scn->d.d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
       goto out;
--- elfutils/libelf/gelf_update_symshndx.c
+++ elfutils/libelf/gelf_update_symshndx.c
@@ -77,12 +77,6 @@ gelf_update_symshndx (symdata, shndxdata
   if (symdata == NULL)
     return 0;
 
-  if (unlikely (ndx < 0))
-    {
-      __libelf_seterrno (ELF_E_INVALID_INDEX);
-      return 0;
-    }
-
   if (unlikely (symdata_scn->d.d_type != ELF_T_SYM))
     {
       /* The type of the data better should match.  */
@@ -128,7 +122,8 @@ gelf_update_symshndx (symdata, shndxdata
 	}
 
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf32_Sym) > symdata_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf32_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf32_Sym) > symdata_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
@@ -151,7 +146,8 @@ gelf_update_symshndx (symdata, shndxdata
   else
     {
       /* Check whether we have to resize the data buffer.  */
-      if (unlikely ((ndx + 1) * sizeof (Elf64_Sym) > symdata_scn->d.d_size))
+      if (INVALID_NDX (ndx, Elf64_Sym)
+	  || unlikely ((ndx + 1) * sizeof (Elf64_Sym) > symdata_scn->d.d_size))
 	{
 	  __libelf_seterrno (ELF_E_INVALID_INDEX);
 	  goto out;
--- elfutils/libelf/gelf_update_versym.c
+++ elfutils/libelf/gelf_update_versym.c
@@ -75,7 +75,7 @@ gelf_update_versym (data, ndx, src)
   assert (sizeof (GElf_Versym) == sizeof (Elf64_Versym));
 
   /* Check whether we have to resize the data buffer.  */
-  if (unlikely (ndx < 0)
+  if (INVALID_NDX (ndx, GElf_Versym)
       || unlikely ((ndx + 1) * sizeof (GElf_Versym) > data_scn->d.d_size))
     {
       __libelf_seterrno (ELF_E_INVALID_INDEX);
--- elfutils/libelf/libelfP.h
+++ elfutils/libelf/libelfP.h
@@ -611,4 +611,13 @@ extern uint32_t __libelf_crc32 (uint32_t
 /* Align offset to 4 bytes as needed for note name and descriptor data.  */
 #define NOTE_ALIGN(n)	(((n) + 3) & -4U)
 
+/* Convenience macro.  Assumes int NDX and TYPE with size at least
+   2 bytes.  */
+#if SIZE_MAX > 4294967295U
+# define INVALID_NDX(ndx, type) unlikely (ndx < 0)
+#else
+# define INVALID_NDX(ndx, type) \
+  unlikely ((unsigned int) (ndx) >= SIZE_MAX / sizeof (type))
+#endif
+
 #endif  /* libelfP.h */
--- elfutils/po/es.po
+++ elfutils/po/es.po
@@ -2085,7 +2085,7 @@ msgstr "no"
 #: ../src/readelf.c:4105
 #, c-format
 msgid "cannot get .debug_aranges content: %s"
-msgstr ""
+msgstr "no se ha podido obtener contenido de .debug_aranges: %s"
 
 #: ../src/readelf.c:4110
 #, c-format
@@ -2111,7 +2111,7 @@ msgstr ""
 #: ../src/readelf.c:4161
 #, c-format
 msgid "cannot get .debug_ranges content: %s"
-msgstr ""
+msgstr "no se ha podido obtener contenido de .debug_ranges: %s"
 
 #: ../src/readelf.c:4166
 #: ../src/readelf.c:4623
@@ -2237,9 +2237,9 @@ msgid ""
 msgstr ""
 
 #: ../src/readelf.c:5194
-#, c-format
+#, fuzzy, c-format
 msgid "cannot get DIE at offset %<PRIu64> in section '%s': %s"
-msgstr ""
+msgstr "no se ha podido obtener DIE en offset %<PRIu64> en la sección '%s': %s"
 
 #: ../src/readelf.c:5205
 #, fuzzy, c-format
@@ -2247,9 +2247,9 @@ msgid "cannot get DIE offset: %s"
 msgstr "%s: no se puede desplazar a la posición %s"
 
 #: ../src/readelf.c:5213
-#, c-format
+#, fuzzy, c-format
 msgid "cannot get tag of DIE at offset %<PRIu64> in section '%s': %s"
-msgstr ""
+msgstr "no se ha podido obtener etiqueta de DIE en offset %<PRIu64> en la sección '%s': %s"
 
 #: ../src/readelf.c:5242
 #, fuzzy, c-format
@@ -2291,9 +2291,9 @@ msgid ""
 msgstr ""
 
 #: ../src/readelf.c:5368
-#, c-format
+#, fuzzy, c-format
 msgid "invalid data at offset %tu in section [%zu] '%s'"
-msgstr ""
+msgstr "datos inválidos en offset %ty en la sección [%zu] '%s'"
 
 #: ../src/readelf.c:5383
 #, fuzzy, c-format
@@ -2326,9 +2326,9 @@ msgstr ""
 " Declaraciones de Número de Línea:\n"
 
 #: ../src/readelf.c:5497
-#, c-format
+#, fuzzy, c-format
 msgid " special opcode %u: address+%u = %s, line%+d = %zu\n"
-msgstr ""
+msgstr " special opcode %u: address+%u = %s, line%+d = %zu\n"
 
 #: ../src/readelf.c:5517
 #, fuzzy, c-format
@@ -2348,9 +2348,9 @@ msgid "set address to %s\n"
 msgstr "La dirección de la sección %s se estableció a "
 
 #: ../src/readelf.c:5558
-#, c-format
+#, fuzzy, c-format
 msgid "define new file: dir=%u, mtime=%<PRIu64>, length=%<PRIu64>, name=%s\n"
-msgstr ""
+msgstr "definir nuevo archivo: dir=%u, mtime=%<PRIu64>, length=%<PRIu64>, name=%s\n"
 
 #. Unknown, ignore it.
 #: ../src/readelf.c:5567
@@ -2403,7 +2403,7 @@ msgstr "  Avanzar el PC por %lu para %lx
 #: ../src/readelf.c:5657
 #, c-format
 msgid "advance address by fixed value %u to %s\n"
-msgstr ""
+msgstr "dirección avanzada arreglando el valor %u a %s\n"
 
 #. Takes no argument.
 #: ../src/readelf.c:5666
@@ -2430,7 +2430,7 @@ msgstr[1] ""
 #: ../src/readelf.c:5712
 #, c-format
 msgid "cannot get .debug_loc content: %s"
-msgstr ""
+msgstr "no es posible obtener contenido de .debug_loc: %s"
 
 #. First entry in a list.
 #: ../src/readelf.c:5767
@@ -2446,17 +2446,17 @@ msgstr "           %s..%s"
 #: ../src/readelf.c:5822
 #, c-format
 msgid "cannot get macro information section data: %s"
-msgstr ""
+msgstr "no es posible obtener datos de la sección de macro información: %s"
 
 #: ../src/readelf.c:5901
 #, c-format
 msgid "%*s*** non-terminated string at end of section"
-msgstr ""
+msgstr "%*s*** cadena no finalizada al final de la sección"
 
 #: ../src/readelf.c:5969
-#, c-format
+#, fuzzy, c-format
 msgid " [%5d] DIE offset: %6<PRId64>, CU DIE offset: %6<PRId64>, name: %s\n"
-msgstr ""
+msgstr " [%5d] DIE offset: %6<PRId64>, CU DIE offset: %6<PRId64>, nombre: %s\n"
 
 #: ../src/readelf.c:6008
 #, c-format
@@ -2522,15 +2522,15 @@ msgid "invalid TType encoding"
 msgstr "especificada una codificación inválida"
 
 #: ../src/readelf.c:6303
-#, c-format
+#, fuzzy, c-format
 msgid "cannot get debug context descriptor: %s"
-msgstr ""
+msgstr "no es posible obtener un descriptor de contexto de debug: %s"
 
 #: ../src/readelf.c:6438
 #: ../src/readelf.c:7016
-#, c-format
+#, fuzzy, c-format
 msgid "cannot convert core note data: %s"
-msgstr ""
+msgstr "no es posible convertir datos de la nota proncipal: %s"
 
 #: ../src/readelf.c:6743
 #, fuzzy, c-format
@@ -2594,7 +2594,7 @@ msgstr ""
 #: ../src/readelf.c:7287
 #, c-format
 msgid "cannot get data for section [%Zu] '%s': %s"
-msgstr ""
+msgstr "no es posible obtener datos de la sección [%Zu] '%s': %s"
 
 #: ../src/readelf.c:7269
 #, c-format
@@ -2651,9 +2651,9 @@ msgid ""
 msgstr ""
 
 #: ../src/readelf.c:7450
-#, c-format
+#, fuzzy, c-format
 msgid "cannot extract member at offset %Zu in '%s': %s"
-msgstr ""
+msgstr "no es posible extraer miembro en offset %Zu in '%s': %s"
 
 #: ../src/readelf.c:7455
 #, fuzzy, c-format
@@ -2662,7 +2662,7 @@ msgstr "Comprueba si el archivador conti
 
 #: ../src/size.c:68
 msgid "Use the output format FORMAT.  FORMAT can be `bsd' or `sysv'.  The default is `bsd'"
-msgstr ""
+msgstr "Utilice el formato de salida FORMAT. FORMAT puede set tanto `bsd' como `sysv'. El establecido por defecto es `bsd'"
 
 #: ../src/size.c:70
 #, fuzzy
@@ -2691,20 +2691,20 @@ msgstr "lo mismo que --format=posix"
 
 #: ../src/size.c:78
 msgid "Similar to `--format=sysv' output but in one line"
-msgstr ""
+msgstr "Similar a la salida `--format=sysv' pero en una sola línea"
 
 #: ../src/size.c:82
 msgid "Print size and permission flags for loadable segments"
-msgstr ""
+msgstr "Imprime el tamaño y las marcas de permiso para los segmentos posibles de ser cargados"
 
 #: ../src/size.c:83
 msgid "Display the total sizes (bsd only)"
-msgstr ""
+msgstr "Muestra el tamaño total (bsd solamente)"
 
 #. Short description of program.
 #: ../src/size.c:88
 msgid "List section sizes of FILEs (a.out by default)."
-msgstr ""
+msgstr "Lista los tamaños de sección de FILEs (por defecto a.out). "
 
 #: ../src/size.c:269
 #, fuzzy, c-format
@@ -2733,8 +2733,9 @@ msgid "(TOTALS)\n"
 msgstr "calcular totales"
 
 #: ../src/strip.c:73
+#, fuzzy
 msgid "Place stripped output into FILE"
-msgstr ""
+msgstr "Coloca la salida obtenida en FILE"
 
 #: ../src/strip.c:74
 #, fuzzy
@@ -2773,7 +2774,7 @@ msgstr " Remueve símbolos y secciones d
 #: ../src/strip.c:185
 #, c-format
 msgid "Only one input file allowed together with '-o' and '-f'"
-msgstr ""
+msgstr "Solo se permite ingresar un archivo junto con '-o' y '-f'"
 
 #: ../src/strip.c:221
 #, fuzzy, c-format
@@ -2794,7 +2795,7 @@ msgstr "se desconoce la opción -m%s= es
 #: ../src/strip.c:259
 #, c-format
 msgid "-R option supports only .comment section"
-msgstr ""
+msgstr "la opción -R es soportada sólo en la sección .comment"
 
 #: ../src/strip.c:297
 #: ../src/strip.c:321
@@ -2808,9 +2809,9 @@ msgid "while opening '%s'"
 msgstr "mientras se abría %s"
 
 #: ../src/strip.c:349
-#, c-format
+#, fuzzy, c-format
 msgid "%s: cannot use -o or -f when stripping archive"
-msgstr ""
+msgstr "%s: no puede utilzarse -o o -f cuando se extrae un archivo"
 
 #: ../src/strip.c:447
 #, fuzzy, c-format
@@ -2892,7 +2893,7 @@ msgstr "Error al copiar «%B»."
 #: ../src/strip.c:1808
 #, c-format
 msgid "cannot set access and modification date of '%s'"
-msgstr ""
+msgstr "no es posible establecer acceso y fecha de modificación de '%s'"
 
 #: ../src/ld.c:87
 #, fuzzy
@@ -2903,11 +2904,11 @@ msgstr ""
 
 #: ../src/ld.c:89
 msgid "Include whole archives in the output from now on."
-msgstr ""
+msgstr "A partir de ahora incluye archivos completos en la salida."
 
 #: ../src/ld.c:91
 msgid "Stop including the whole arhives in the output."
-msgstr ""
+msgstr "Deja de incluir archivos completos en la salida."
 
 #: ../src/ld.c:92
 #: ../src/ld.c:106
@@ -2933,11 +2934,12 @@ msgstr "RUTA"
 
 #: ../src/ld.c:96
 msgid "Add PATH to list of directories files are searched in."
-msgstr ""
+msgstr "Agrega PATH a la lista de los directorios en los que se realiza la búsqueda"
 
 #: ../src/ld.c:98
+#, fuzzy
 msgid "Only set DT_NEEDED for following dynamic libs if actually used"
-msgstr ""
+msgstr "Solo se define DT_NEEDED para las librerías dinámicas siguientes, están siendo utilizadas"
 
 #: ../src/ld.c:100
 #, fuzzy
@@ -2946,7 +2948,7 @@ msgstr "Siempre establece DT_NEEDED para
 
 #: ../src/ld.c:102
 msgid "Ignore LD_LIBRARY_PATH environment variable."
-msgstr ""
+msgstr "Ignora la variable de entorno LD_LIBRARY_PATH."
 
 #: ../src/ld.c:105
 #, fuzzy
@@ -2962,7 +2964,7 @@ msgstr "  -o <fichero>             Coloc
 
 #: ../src/ld.c:109
 msgid "Object is marked to not use default search path at runtime."
-msgstr ""
+msgstr "Los objetos son marcados para que no utilicen el camino de búsqueda establecido por defecto en el momento de su ejecución."
 
 #: ../src/ld.c:111
 #, fuzzy
@@ -2971,23 +2973,23 @@ msgstr "Apaga --whole-archive"
 
 #: ../src/ld.c:112
 msgid "Default rules of extracting from archive; weak references are not enough."
-msgstr ""
+msgstr "Reglas establecidas por defecto para extraer desde el archivo; las referencias débiles no son suficientes."
 
 #: ../src/ld.c:116
 msgid "Weak references cause extraction from archive."
-msgstr ""
+msgstr "Referencias débiles causan extracción desde archivo."
 
 #: ../src/ld.c:118
 msgid "Allow multiple definitions; first is used."
-msgstr ""
+msgstr "Permite definiciones múltiples; es utilizada la primera."
 
 #: ../src/ld.c:120
 msgid "Disallow/allow undefined symbols in DSOs."
-msgstr ""
+msgstr "Habilita/deshabilita símbolos indefinidos en DSOs."
 
 #: ../src/ld.c:123
 msgid "Object requires immediate handling of $ORIGIN."
-msgstr ""
+msgstr "Los objetos requieren manipulación inmediata de $ORIGIN."
 
 #: ../src/ld.c:125
 #, fuzzy
@@ -3001,23 +3003,24 @@ msgstr "La constante nombrada '%s' en %L
 
 #: ../src/ld.c:129
 msgid "Mark object to be initialized first."
-msgstr ""
+msgstr "Marca el objeto para ser inicializado primero."
 
 #: ../src/ld.c:131
+#, fuzzy
 msgid "Enable/disable lazy-loading flag for following dependencies."
-msgstr ""
+msgstr "Activa/desactiva marca lazy-loading para las siguientes dependencias."
 
 #: ../src/ld.c:133
 msgid "Mark object as not loadable with 'dlopen'."
-msgstr ""
+msgstr "Marca el objeto como no cargable con 'dlopen'"
 
 #: ../src/ld.c:135
 msgid "Ignore/record dependencies on unused DSOs."
-msgstr ""
+msgstr "Ignora/registra dependencias sobre DSOs no utilizados."
 
 #: ../src/ld.c:137
 msgid "Generated DSO will be a system library."
-msgstr ""
+msgstr "El DSO generado será una librería del sistema. "
 
 #: ../src/ld.c:138
 #, fuzzy
@@ -3055,8 +3058,9 @@ msgid "Strip debugging symbols."
 msgstr "Descarta los símbolos de depuración"
 
 #: ../src/ld.c:149
+#, fuzzy
 msgid "Assume pagesize for the target system to be SIZE."
-msgstr ""
+msgstr "Asume que será SIZE el pagesize para el objeto del sistema."
 
 #: ../src/ld.c:151
 #, fuzzy
@@ -3079,8 +3083,9 @@ msgid "Generate relocatable object."
 msgstr "Genera salida reubicable"
 
 #: ../src/ld.c:159
+#, fuzzy
 msgid "Causes symbol not assigned to a version be reduced to local."
-msgstr ""
+msgstr "Hace que un símbolo no asinado a ninguna versión sea reducido a local."
 
 #: ../src/ld.c:160
 #, fuzzy
@@ -3108,15 +3113,17 @@ msgstr ""
 
 #: ../src/ld.c:171
 msgid "Create .eh_frame_hdr section"
-msgstr ""
+msgstr "Crea una sección .eh_frame_hdr"
 
 #: ../src/ld.c:173
+#, fuzzy
 msgid "Set hash style to sysv, gnu or both."
-msgstr ""
+msgstr "Establece el hash style a sysv, gnu o ambos."
 
 #: ../src/ld.c:175
+#, fuzzy
 msgid "Generate build ID note (md5, sha1 (default), uuid)."
-msgstr ""
+msgstr "Crea una nota del ID de compilación (md5, sha1 (por defecto), uuid)."
 
 #: ../src/ld.c:177
 #, fuzzy
@@ -3135,7 +3142,7 @@ msgstr "Rastrea la apertura de ficheros"
 
 #: ../src/ld.c:181
 msgid "Trade speed for less memory usage"
-msgstr ""
+msgstr "Intercambia velocidad por menor utilización de la memoria"
 
 #: ../src/ld.c:182
 #, fuzzy
@@ -3168,8 +3175,9 @@ msgstr "|NOMBRE|usa el juego de caracter
 
 #. Short description of program.
 #: ../src/ld.c:197
+#, fuzzy
 msgid "Combine object and archive files."
-msgstr ""
+msgstr "Combina objeto y archivos de almacenamiento."
 
 #. Strings for arguments in help texts.
 #: ../src/ld.c:200
@@ -3232,7 +3240,7 @@ msgstr "estilo de numeración de cuerpo 
 #: ../src/ld.c:785
 #, c-format
 msgid "More than one output file name given."
-msgstr ""
+msgstr "Se ha dado más de un nombre de arhivo de salido. "
 
 #: ../src/ld.c:802
 #, fuzzy, c-format
@@ -3257,7 +3265,7 @@ msgstr "El parámetro '%s' es desconocid
 #: ../src/ld.c:1150
 #, c-format
 msgid "could not find input file to determine output file format"
-msgstr ""
+msgstr "no se ha podido encontrar un archivo de entrada que determine el formato del archivo de salida"
 
 #: ../src/ld.c:1152
 #, fuzzy, c-format
@@ -3284,19 +3292,19 @@ msgid "cannot create string table"
 msgstr "<índice de la tabla de cadenas: %3ld>"
 
 #: ../src/ldgeneric.c:255
-#, c-format
+#, fuzzy, c-format
 msgid "cannot load ld backend library '%s': %s"
-msgstr ""
+msgstr "no se ha podido cargar la librería ld backend '%s': %s"
 
 #: ../src/ldgeneric.c:265
-#, c-format
+#, fuzzy, c-format
 msgid "cannot find init function in ld backend library '%s': %s"
-msgstr ""
+msgstr "no se ha podido encontrar la función init en la librería ld backend '%s': %s"
 
 #: ../src/ldgeneric.c:310
 #, c-format
 msgid "%s listed more than once as input"
-msgstr ""
+msgstr "%s listado más de una vez como entrada"
 
 #: ../src/ldgeneric.c:424
 #, fuzzy, c-format
@@ -3337,14 +3345,14 @@ msgstr "no se puede obtener el grupo de 
 #. despite the SHF_GROUP flag.  This is an error in the input
 #. file.
 #: ../src/ldgeneric.c:840
-#, c-format
+#, fuzzy, c-format
 msgid "%s: section '%s' with group flag set does not belong to any group"
-msgstr ""
+msgstr "%s: la sección '%s' con el grupo definir marca no pertenece a ningún grupo"
 
 #: ../src/ldgeneric.c:885
 #, c-format
 msgid "%s: section [%2d] '%s' is not in the correct section group"
-msgstr ""
+msgstr "%s: la sección [%2d] '%s' no se encuentra en el grupo de sección correcto"
 
 #. This should never happen.
 #: ../src/ldgeneric.c:1156
@@ -3361,22 +3369,22 @@ msgstr "Versión de ABI del fichero ELF 
 #: ../src/ldgeneric.c:1250
 #, c-format
 msgid "%s: only files of type ET_REL might contain section groups"
-msgstr ""
+msgstr "%s: solo archivos de tipo ET_REL pueden contener grupos de sección"
 
 #: ../src/ldgeneric.c:1302
 #, c-format
 msgid "%s: cannot determine signature of section group [%2zd] '%s': %s"
-msgstr ""
+msgstr "%s: no es posible determinar la firma del grupo de sección [%2zd] '%s': %s "
 
 #: ../src/ldgeneric.c:1314
 #, c-format
 msgid "%s: cannot get content of section group [%2zd] '%s': %s'"
-msgstr ""
+msgstr "%s: no es posible obtener el contenido de la sección del grupo [%2zd] '%s': %s'"
 
 #: ../src/ldgeneric.c:1328
 #, c-format
 msgid "%s: group member %zu of section group [%2zd] '%s' has too high index: %<PRIu32>"
-msgstr ""
+msgstr "%s el miembro del grupo %zu del grupo de sección [%2zd] '%s' posee el índice demsiado alto: %<PRIu32>"
 
 #: ../src/ldgeneric.c:1350
 #, fuzzy, c-format
@@ -3386,7 +3394,7 @@ msgstr "%s tiene un tipo de fichero desc
 #: ../src/ldgeneric.c:1729
 #, c-format
 msgid "cannot get descriptor for ELF file (%s:%d): %s\n"
-msgstr ""
+msgstr "no es posible obtener descriptor para el archivo ELF (%s:%d): %s\n"
 
 #: ../src/ldgeneric.c:1899
 #, fuzzy, c-format
@@ -3401,17 +3409,17 @@ msgstr "El archivo de zona no puede ser 
 #: ../src/ldgeneric.c:2032
 #, c-format
 msgid "%s: input file incompatible with ELF machine type %s\n"
-msgstr ""
+msgstr "%s: el archivo ingresado es incompatible con una máquina ELF tipo %s\n"
 
 #: ../src/ldgeneric.c:2044
 #, c-format
 msgid "%s: cannot get section header string table index: %s\n"
-msgstr ""
+msgstr "%s: no se ha podido obtener un índice para la tabla de la cadena del encabezado de la sección: %s\n"
 
 #: ../src/ldgeneric.c:2073
 #, c-format
 msgid "cannot use DSO '%s' when generating relocatable object file"
-msgstr ""
+msgstr "no es posible utilizar DSO '%s' al general un archivo de objeto realojable"
 
 #: ../src/ldgeneric.c:2158
 #, fuzzy, c-format
@@ -3429,12 +3437,12 @@ msgstr "símbolo indefinido `%s' en la o
 #: ../src/ldgeneric.c:2702
 #, c-format
 msgid "cannot create ELF descriptor for output file: %s"
-msgstr ""
+msgstr "no es posible crear un descriptor ELF para el archivo de salida: %s"
 
 #: ../src/ldgeneric.c:2709
 #, c-format
 msgid "could not create ELF header for output file: %s"
-msgstr ""
+msgstr "no es posible crear un encabezado ELF para el archivo de salida: %s"
 
 #: ../src/ldgeneric.c:3224
 #: ../src/ldgeneric.c:3294
@@ -3453,14 +3461,14 @@ msgid "cannot create section for output 
 msgstr "no se puede crear el fichero de salida `%s' para la categoría `%s'"
 
 #: ../src/ldgeneric.c:3444
-#, c-format
+#, fuzzy, c-format
 msgid "address computation expression contains variable '%s'"
-msgstr ""
+msgstr "las expresiones de dirección en lenguaje de computación contienen la variable '%s'"
 
 #: ../src/ldgeneric.c:3489
-#, c-format
+#, fuzzy, c-format
 msgid "argument '%<PRIuMAX>' of ALIGN in address computation expression is no power of two"
-msgstr ""
+msgstr "el argumento '%<PRIuMAX>' de ALIGN en direcciones de expresiones computacionales es no más poderoso que dos "
 
 #: ../src/ldgeneric.c:3684
 #, fuzzy, c-format
@@ -3470,17 +3478,17 @@ msgstr "%P: aviso: no se puede encontrar
 #: ../src/ldgeneric.c:3690
 #, c-format
 msgid "no entry symbol specified: defaulting to %#0*<PRIx64>"
-msgstr ""
+msgstr "no se ha especificado una entrada de símbolo: estableciendo por defecto a %#0*<PRIx64>"
 
 #: ../src/ldgeneric.c:3920
-#, c-format
+#, fuzzy, c-format
 msgid "cannot create GNU hash table section for output file: %s"
-msgstr ""
+msgstr "no es posible crear una sección para la tabla GNU hash del archivo de salida: %s"
 
 #: ../src/ldgeneric.c:4071
 #, c-format
 msgid "cannot create hash table section for output file: %s"
-msgstr ""
+msgstr "no es posible crear una sección para la tabla hash del archivo de salida: %s"
 
 #: ../src/ldgeneric.c:4114
 #, fuzzy, c-format
@@ -3490,17 +3498,17 @@ msgstr "%F%P: no se puede crear la tabla
 #: ../src/ldgeneric.c:4191
 #, c-format
 msgid "cannot convert section data to file format: %s"
-msgstr ""
+msgstr "no es posible convertir los datos de la sección en formato de archivo: %s"
 
 #: ../src/ldgeneric.c:4200
 #, c-format
 msgid "cannot convert section data to memory format: %s"
-msgstr ""
+msgstr "no es posible convertir datos de la sección en formato de memoria: %s"
 
 #: ../src/ldgeneric.c:4261
 #, c-format
 msgid "cannot read enough data for UUID"
-msgstr ""
+msgstr "no es posible leer suficientes datos para el UUID"
 
 #: ../src/ldgeneric.c:4358
 #: ../src/ldgeneric.c:4379
@@ -3508,13 +3516,13 @@ msgstr ""
 #: ../src/ldgeneric.c:6062
 #, c-format
 msgid "cannot create symbol table for output file: %s"
-msgstr ""
+msgstr "no es posible crear tabla de símbolo para el comando de salida: %s"
 
 #: ../src/ldgeneric.c:5300
 #: ../src/ldgeneric.c:5852
-#, c-format
+#, fuzzy, c-format
 msgid "section index too large in dynamic symbol table"
-msgstr ""
+msgstr "el índice de la sección es demasiado extenso en la tabla dinámica de símbolo"
 
 #: ../src/ldgeneric.c:5745
 #, fuzzy, c-format
@@ -3524,7 +3532,7 @@ msgstr "%F%P: no se puede crear la tabla
 #: ../src/ldgeneric.c:5818
 #, c-format
 msgid "cannot create dynamic symbol table for output file: %s"
-msgstr ""
+msgstr "no es posible crear tabla dinámica de símbolo para el archivo de salida: %s"
 
 #: ../src/ldgeneric.c:5994
 #, fuzzy, c-format
@@ -3555,9 +3563,9 @@ msgid "while determining file layout: %s
 msgstr "Error al crear el archivo %B."
 
 #: ../src/ldgeneric.c:6388
-#, c-format
+#, fuzzy, c-format
 msgid "internal error: non-nobits section follows nobits section"
-msgstr ""
+msgstr "error interno: sección non-nobits a continuación de sección nobits"
 
 #: ../src/ldgeneric.c:6925
 #, fuzzy, c-format
@@ -3593,7 +3601,7 @@ msgstr "no se puede generar el fichero d
 #: ../src/ldgeneric.c:7011
 #, c-format
 msgid "WARNING: temporary output file overwritten before linking finished"
-msgstr ""
+msgstr "AVISO: archivo de salida temporar sobreescrito antes que haya concluido el enlazamiento"
 
 #. This cannot be implemented generally.  There should have been a
 #. machine dependent implementation and we should never have arrived
@@ -3630,9 +3638,9 @@ msgid "cannot allocate GOTPLT section: %
 msgstr "No se puede asignar espacio para el búfer"
 
 #: ../src/i386_ld.c:661
-#, c-format
+#, fuzzy, c-format
 msgid "initial-executable TLS relocation cannot be used "
-msgstr ""
+msgstr "no es posible utilizar el realojamiento del TLS ejecutable en el inicio"
 
 #: ../src/ldscript.y:178
 #, fuzzy
@@ -3650,36 +3658,38 @@ msgid "while reading linker script '%s':
 msgstr "Se encontró fin de archivo en la línea %d, antes de terminar de leer los datos."
 
 #: ../src/ldscript.y:745
-#, c-format
+#, fuzzy, c-format
 msgid "symbol '%s' in declared both local and global for unnamed version"
-msgstr ""
+msgstr "el símbolo '%s' en declarado tanto local como global para la versión no identificada"
 
 #: ../src/ldscript.y:747
-#, c-format
+#, fuzzy, c-format
 msgid "symbol '%s' in declared both local and global for version '%s'"
-msgstr ""
+msgstr "el símbolo '%s' en declarado tanto local como global para la versión '%s'"
 
 #: ../src/ldscript.y:767
 #: ../src/ldscript.y:774
-#, c-format
+#, fuzzy, c-format
 msgid "default visibility set as local and global"
-msgstr ""
+msgstr "la visibilidad establecida por defecto está definida tanto local como global"
 
 #: ../src/elflint.c:71
 msgid "Be extremely strict, flag level 2 features."
-msgstr ""
+msgstr "Sea extremadamente estricto, recursos de marca de nivel 2."
 
 #: ../src/elflint.c:72
 msgid "Do not print anything if successful"
-msgstr ""
+msgstr "No imprime nada si es exitoso"
 
 #: ../src/elflint.c:73
+#, fuzzy
 msgid "Binary is a separate debuginfo file"
-msgstr ""
+msgstr "Binario es un archivo debuginfo diferente "
 
 #: ../src/elflint.c:75
+#, fuzzy
 msgid "Binary has been created with GNU ld and is therefore known to be broken in certain ways"
-msgstr ""
+msgstr "Binario ha sido creado con GNU Id y por lo tanto es sabido que puede ser roto de determinadas maneras"
 
 #. Short description of program.
 #: ../src/elflint.c:81
@@ -3702,9 +3712,9 @@ msgid "No errors"
 msgstr "    NO SE HAN ENCONTRADO ERRORES\n"
 
 #: ../src/elflint.c:301
-#, c-format
+#, fuzzy, c-format
 msgid " error while freeing sub-ELF descriptor: %s\n"
-msgstr ""
+msgstr " error al intentar liberar descriptor sub-ELF: %s\n"
 
 #. We cannot do anything.
 #: ../src/elflint.c:309
@@ -3715,17 +3725,17 @@ msgstr "No es un fichero ELF - tiene los
 #: ../src/elflint.c:368
 #, c-format
 msgid "e_ident[%d] == %d is no known class\n"
-msgstr ""
+msgstr "e_ident[%d] == %d es una clase desconocida\n"
 
 #: ../src/elflint.c:373
 #, c-format
 msgid "e_ident[%d] == %d is no known data encoding\n"
-msgstr ""
+msgstr "e_ident[%d] == %d es una codificación de datos desconocida\n"
 
 #: ../src/elflint.c:377
 #, c-format
 msgid "unknown ELF header version number e_ident[%d] == %d\n"
-msgstr ""
+msgstr "número de versión de encabezado ELF desconocido e_ident[%d] == %d\n"
 
 #: ../src/elflint.c:382
 #, fuzzy, c-format
@@ -3763,14 +3773,14 @@ msgid "invalid program header offset\n"
 msgstr "Operando inválido para `OFFSET'"
 
 #: ../src/elflint.c:417
-#, c-format
+#, fuzzy, c-format
 msgid "executables and DSOs cannot have zero program header offset\n"
-msgstr ""
+msgstr "tanto los ejecutables como los DSOs no pueden tener offset de encabezado de programa cero\n"
 
 #: ../src/elflint.c:421
 #, c-format
 msgid "invalid number of program header entries\n"
-msgstr ""
+msgstr "cantidad no válida de entradas del encabezado del programa\n"
 
 #: ../src/elflint.c:429
 #, fuzzy, c-format
@@ -3780,12 +3790,12 @@ msgstr "falló la asignación de la tabl
 #: ../src/elflint.c:432
 #, c-format
 msgid "section header table must be present\n"
-msgstr ""
+msgstr "debe encontrarse presente una tabla de encabezado de sección\n"
 
 #: ../src/elflint.c:446
 #, c-format
 msgid "invalid number of section header table entries\n"
-msgstr ""
+msgstr "cantidad no válida de entradas en la tabla del encabezado de sección\n"
 
 #: ../src/elflint.c:463
 #, fuzzy, c-format
@@ -3801,41 +3811,41 @@ msgstr "%P%F: sintaxis inválida en los 
 #: ../src/elflint.c:492
 #, c-format
 msgid "invalid ELF header size: %hd\n"
-msgstr ""
+msgstr "tamaño inválido del encabezado ELF: %hd\n"
 
 #: ../src/elflint.c:478
 #: ../src/elflint.c:495
 #, c-format
 msgid "invalid program header size: %hd\n"
-msgstr ""
+msgstr "tamaño inválido del encabezado del programa: %hd\n"
 
 #: ../src/elflint.c:481
 #: ../src/elflint.c:498
 #, c-format
 msgid "invalid program header position or size\n"
-msgstr ""
+msgstr "tamaño o posición no válidos del encabezado del programa\n"
 
 #: ../src/elflint.c:484
 #: ../src/elflint.c:501
 #, c-format
 msgid "invalid section header size: %hd\n"
-msgstr ""
+msgstr "tamaño inválido del encabezado de sección: %hd\n"
 
 #: ../src/elflint.c:487
 #: ../src/elflint.c:504
 #, c-format
 msgid "invalid section header position or size\n"
-msgstr ""
+msgstr "tamaño o posición no válidos del encabezado de sección\n"
 
 #: ../src/elflint.c:548
-#, c-format
+#, fuzzy, c-format
 msgid "section [%2d] '%s': section with SHF_GROUP flag set not part of a section group\n"
-msgstr ""
+msgstr "sección [%2d] '%s': sección definida con la marca SHF_GROUP no es parte de una sección de grupo\n"
 
 #: ../src/elflint.c:552
-#, c-format
+#, fuzzy, c-format
 msgid "section [%2d] '%s': section group [%2zu] '%s' does not preceed group member\n"
-msgstr ""
+msgstr "sección [%2d] '%s': el grupo de sección [%2zu] '%s' no precede a ningún miembro de grupo\n"
 
 #: ../src/elflint.c:568
 #: ../src/elflint.c:1393
@@ -3855,17 +3865,17 @@ msgstr "%C: No se puede obtener el conte
 #: ../src/elflint.c:1559
 #, c-format
 msgid "section [%2d] '%s': referenced as string table for section [%2d] '%s' but type is not SHT_STRTAB\n"
-msgstr ""
+msgstr "sección [%2d] '%s': está referenciado como una tabla de cadena para la sección [%2d] '%s' pero no es de tipo SHT_STRTAB\n"
 
 #: ../src/elflint.c:604
 #, c-format
 msgid "section [%2d] '%s': symbol table cannot have more than one extended index section\n"
-msgstr ""
+msgstr "sección [%2d] '%s': la tabla de símbolo no puede tener más de una sección de índice extendido\n"
 
 #: ../src/elflint.c:615
 #, c-format
 msgid "section [%2u] '%s': entry size is does not match ElfXX_Sym\n"
-msgstr ""
+msgstr "sección [%2u] '%s': el tamaño de la entrada no cincide con ElfXX_Sym\n"
 
 #: ../src/elflint.c:624
 #, fuzzy, c-format
@@ -3878,55 +3888,55 @@ msgstr "no se puede definir el símbolo 
 #: ../src/elflint.c:638
 #: ../src/elflint.c:641
 #: ../src/elflint.c:644
-#, c-format
+#, fuzzy, c-format
 msgid "section [%2d] '%s': '%s' in zeroth entry not zero\n"
-msgstr ""
+msgstr "sección [%2d] '%s': '%s' en la entrada zeroth no es igual cero\n"
 
 #: ../src/elflint.c:647
-#, c-format
+#, fuzzy, c-format
 msgid "section [%2d] '%s': XINDEX for zeroth entry not zero\n"
-msgstr ""
+msgstr "sección [%2d] '%s': XINDEX en la entrada zeroth no es igual cero\n"
 
 #: ../src/elflint.c:657
 #, c-format
 msgid "section [%2d] '%s': cannot get symbol %zu: %s\n"
-msgstr ""
+msgstr "sección [%2d] '%s': no es posible obtener el símbolo %zu: %s\n"
 
 #: ../src/elflint.c:666
 #, c-format
 msgid "section [%2d] '%s': symbol %zu: invalid name value\n"
-msgstr ""
+msgstr "sección [%2d] '%s': símbolo %zu: valor de nombre inválido\n"
 
 #: ../src/elflint.c:679
-#, c-format
+#, fuzzy, c-format
 msgid "section [%2d] '%s': symbol %zu: too large section index but no extended section index section\n"
-msgstr ""
+msgstr "sección [%2d] '%s': símbolo %zu: el índice de sección es demasiado extenso, y no no existe una sección para índice de sección extendido\n"
 
 #: ../src/elflint.c:685
 #, c-format
 msgid "section [%2d] '%s': symbol %zu: XINDEX used for index which would fit in st_shndx (%<PRIu32>)\n"
-msgstr ""
+msgstr "sección [%2d] '%s': símbolol %zu: XINDEX es utilizado para índice que pueda caber en st_shndx (%<PRIu32>)\n"
 
 #. || sym->st_shndx > SHN_HIRESERVE  always false
 #: ../src/elflint.c:697
 #, c-format
 msgid "section [%2d] '%s': symbol %zu: invalid section index\n"
-msgstr ""
+msgstr "sección [%2d] '%s': símbolo %zu: índice de sección inválido\n"
 
 #: ../src/elflint.c:705
 #, c-format
 msgid "section [%2d] '%s': symbol %zu: unknown type\n"
-msgstr ""
+msgstr "sección [%2d] '%s': símbolo %zu: tipo desconocido\n"
 
 #: ../src/elflint.c:709
 #, c-format
 msgid "section [%2d] '%s': symbol %zu: unknown symbol binding\n"
-msgstr ""
+msgstr "sección [%2d] '%s': símbolo %zu: asociación de símbolo desconocida\n"
 
 #: ../src/elflint.c:717
 #, c-format
 msgid "section [%2d] '%s': symbol %zu: COMMON only allowed in relocatable files\n"
-msgstr ""
+msgstr "sección [%2d] '%s': símbolo %zu: COMMON solo es permitido en archivos realojables\n"
 
 #: ../src/elflint.c:721
 #, c-format
--- elfutils/src/ChangeLog
+++ elfutils/src/ChangeLog
@@ -1376,6 +1376,16 @@
 	object symbols or symbols with unknown type.
 	(check_rel): Likewise.
 
+2005-06-09  Roland McGrath  <roland@redhat.com>
+
+	* readelf.c (handle_dynamic, handle_symtab): Check for bogus sh_link.
+	(handle_verneed, handle_verdef, handle_versym, handle_hash): Likewise.
+	(handle_scngrp): Check for bogus sh_info.
+
+	* strip.c (handle_elf): Check for bogus values in sh_link, sh_info,
+	st_shndx, e_shstrndx, and SHT_GROUP or SHT_SYMTAB_SHNDX data.
+	Don't use assert on input values, instead bail with "illformed" error.
+
 2005-06-08  Roland McGrath  <roland@redhat.com>
 
 	* readelf.c (print_ops): Add consts.
@@ -1421,6 +1431,19 @@
 
 	* readelf.c (dwarf_tag_string): Add new tags.
 
+2005-05-17  Jakub Jelinek  <jakub@redhat.com>
+
+	* elflint.c (check_hash): Don't check entries beyond end of section.
+	(check_note): Don't crash if gelf_rawchunk fails.
+	(section_name): Return <invalid> if gelf_getshdr returns NULL.
+
+2005-05-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* elflint.c (section_name): Return "<invalid>" instead of
+	crashing on invalid section name.
+	(check_symtab, is_rel_dyn, check_rela, check_rel, check_dynamic,
+	check_symtab_shndx, check_hash, check_versym): Robustify.
+
 2005-05-08  Roland McGrath  <roland@redhat.com>
 
 	* strip.c (handle_elf): Don't translate hash and versym data formats,
--- elfutils/src/elflint.c
+++ elfutils/src/elflint.c
@@ -130,6 +130,9 @@ static uint32_t shstrndx;
 /* Array to count references in section groups.  */
 static int *scnref;
 
+/* Number of sections.  */
+static unsigned int shnum;
+
 
 int
 main (int argc, char *argv[])
@@ -318,10 +321,19 @@ section_name (Ebl *ebl, int idx)
 {
   GElf_Shdr shdr_mem;
   GElf_Shdr *shdr;
+  const char *ret;
+
+  if ((unsigned int) idx > shnum)
+    return "<invalid>";
 
   shdr = gelf_getshdr (elf_getscn (ebl->elf, idx), &shdr_mem);
+  if (shdr == NULL)
+    return "<invalid>";
 
-  return elf_strptr (ebl->elf, shstrndx, shdr->sh_name);
+  ret = elf_strptr (ebl->elf, shstrndx, shdr->sh_name);
+  if (ret == NULL)
+    return "<invalid>";
+  return ret;
 }
 
 
@@ -343,10 +355,6 @@ static const int valid_e_machine[] =
   (sizeof (valid_e_machine) / sizeof (valid_e_machine[0]))
 
 
-/* Number of sections.  */
-static unsigned int shnum;
-
-
 static void
 check_elf_header (Ebl *ebl, GElf_Ehdr *ehdr, size_t size)
 {
@@ -611,7 +619,8 @@ section [%2d] '%s': symbol table cannot 
 	  }
       }
 
-  if (shdr->sh_entsize != gelf_fsize (ebl->elf, ELF_T_SYM, 1, EV_CURRENT))
+  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_SYM, 1, EV_CURRENT);
+  if (shdr->sh_entsize != sh_entsize)
     ERROR (gettext ("\
 section [%2u] '%s': entry size is does not match ElfXX_Sym\n"),
 	   idx, section_name (ebl, idx));
@@ -649,7 +658,7 @@ section [%2d] '%s': XINDEX for zeroth en
 	       xndxscnidx, section_name (ebl, xndxscnidx));
     }
 
-  for (size_t cnt = 1; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
+  for (size_t cnt = 1; cnt < shdr->sh_size / sh_entsize; ++cnt)
     {
       sym = gelf_getsymshndx (data, xndxdata, cnt, &sym_mem, &xndx);
       if (sym == NULL)
@@ -669,7 +678,8 @@ section [%2d] '%s': symbol %zu: invalid 
       else
 	{
 	  name = elf_strptr (ebl->elf, shdr->sh_link, sym->st_name);
-	  assert (name != NULL);
+	  assert (name != NULL
+		  || strshdr->sh_type != SHT_STRTAB);
 	}
 
       if (sym->st_shndx == SHN_XINDEX)
@@ -999,9 +1009,11 @@ is_rel_dyn (Ebl *ebl, const GElf_Ehdr *e
     {
       GElf_Shdr rcshdr_mem;
       const GElf_Shdr *rcshdr = gelf_getshdr (scn, &rcshdr_mem);
-      assert (rcshdr != NULL);
 
-      if (rcshdr->sh_type == SHT_DYNAMIC)
+      if (rcshdr == NULL)
+	break;
+
+      if (rcshdr->sh_type == SHT_DYNAMIC && rcshdr->sh_entsize)
 	{
 	  /* Found the dynamic section.  Look through it.  */
 	  Elf_Data *d = elf_getdata (scn, NULL);
@@ -1011,7 +1023,9 @@ is_rel_dyn (Ebl *ebl, const GElf_Ehdr *e
 	    {
 	      GElf_Dyn dyn_mem;
 	      GElf_Dyn *dyn = gelf_getdyn (d, cnt, &dyn_mem);
-	      assert (dyn != NULL);
+
+	      if (dyn == NULL)
+		break;
 
 	      if (dyn->d_tag == DT_RELCOUNT)
 		{
@@ -1025,7 +1039,9 @@ section [%2d] '%s': DT_RELCOUNT used for
 		      /* Does the number specified number of relative
 			 relocations exceed the total number of
 			 relocations?  */
-		      if (dyn->d_un.d_val > shdr->sh_size / shdr->sh_entsize)
+		      if (shdr->sh_entsize != 0
+			  && dyn->d_un.d_val > (shdr->sh_size
+						/ shdr->sh_entsize))
 			ERROR (gettext ("\
 section [%2d] '%s': DT_RELCOUNT value %d too high for this section\n"),
 			       idx, section_name (ebl, idx),
@@ -1185,7 +1201,8 @@ section [%2d] '%s': no relocations for m
 	}
     }
 
-  if (shdr->sh_entsize != gelf_fsize (ebl->elf, reltype, 1, EV_CURRENT))
+  size_t sh_entsize = gelf_fsize (ebl->elf, reltype, 1, EV_CURRENT);
+  if (shdr->sh_entsize != sh_entsize)
     ERROR (gettext (reltype == ELF_T_RELA ? "\
 section [%2d] '%s': section entry size does not match ElfXX_Rela\n" : "\
 section [%2d] '%s': section entry size does not match ElfXX_Rel\n"),
@@ -1408,7 +1425,8 @@ check_rela (Ebl *ebl, GElf_Ehdr *ehdr, G
   Elf_Data *symdata = elf_getdata (symscn, NULL);
   enum load_state state = state_undecided;
 
-  for (size_t cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
+  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_RELA, 1, EV_CURRENT);
+  for (size_t cnt = 0; cnt < shdr->sh_size / sh_entsize; ++cnt)
     {
       GElf_Rela rela_mem;
       GElf_Rela *rela = gelf_getrela (data, cnt, &rela_mem);
@@ -1458,7 +1476,8 @@ check_rel (Ebl *ebl, GElf_Ehdr *ehdr, GE
   Elf_Data *symdata = elf_getdata (symscn, NULL);
   enum load_state state = state_undecided;
 
-  for (size_t cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
+  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_REL, 1, EV_CURRENT);
+  for (size_t cnt = 0; cnt < shdr->sh_size / sh_entsize; ++cnt)
     {
       GElf_Rel rel_mem;
       GElf_Rel *rel = gelf_getrel (data, cnt, &rel_mem);
@@ -1561,7 +1580,8 @@ section [%2d] '%s': referenced as string
 	   shdr->sh_link, section_name (ebl, shdr->sh_link),
 	   idx, section_name (ebl, idx));
 
-  if (shdr->sh_entsize != gelf_fsize (ebl->elf, ELF_T_DYN, 1, EV_CURRENT))
+  size_t sh_entsize = gelf_fsize (ebl->elf, ELF_T_DYN, 1, EV_CURRENT);
+  if (shdr->sh_entsize != sh_entsize)
     ERROR (gettext ("\
 section [%2d] '%s': section entry size does not match ElfXX_Dyn\n"),
 	   idx, section_name (ebl, idx));
@@ -1571,7 +1591,7 @@ section [%2d] '%s': section entry size d
 	   idx, section_name (ebl, idx));
 
   bool non_null_warned = false;
-  for (cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
+  for (cnt = 0; cnt < shdr->sh_size / sh_entsize; ++cnt)
     {
       GElf_Dyn dyn_mem;
       GElf_Dyn *dyn = gelf_getdyn (data, cnt, &dyn_mem);
@@ -1852,6 +1872,8 @@ section [%2d] '%s': entry size does not 
 	   idx, section_name (ebl, idx));
 
   if (symshdr != NULL
+      && shdr->sh_entsize
+      && symshdr->sh_entsize
       && (shdr->sh_size / shdr->sh_entsize
 	  < symshdr->sh_size / symshdr->sh_entsize))
     ERROR (gettext ("\
@@ -1878,6 +1900,12 @@ section [%2d] '%s': extended section ind
     }
 
   Elf_Data *data = elf_getdata (elf_getscn (ebl->elf, idx), NULL);
+  if (data == NULL)
+    {
+      ERROR (gettext ("section [%2d] '%s': cannot get section data\n"),
+ 	     idx, section_name (ebl, idx));
+      return;
+    }
 
   if (*((Elf32_Word *) data->d_buf) != 0)
     ERROR (gettext ("symbol 0 should have zero extended section index\n"));
@@ -1920,7 +1948,7 @@ section [%2d] '%s': hash table section i
 
   size_t maxidx = nchain;
 
-  if (symshdr != NULL)
+  if (symshdr != NULL && symshdr->sh_entsize != 0)
     {
       size_t symsize = symshdr->sh_size / symshdr->sh_entsize;
 
@@ -1931,18 +1959,28 @@ section [%2d] '%s': hash table section i
       maxidx = symsize;
     }
 
+  Elf32_Word *buf = (Elf32_Word *) data->d_buf;
+  Elf32_Word *end = (Elf32_Word *) ((char *) data->d_buf + shdr->sh_size);
   size_t cnt;
   for (cnt = 2; cnt < 2 + nbucket; ++cnt)
-    if (((Elf32_Word *) data->d_buf)[cnt] >= maxidx)
+    {
+      if (buf + cnt >= end)
+	break;
+      else if (buf[cnt] >= maxidx)
       ERROR (gettext ("\
 section [%2d] '%s': hash bucket reference %zu out of bounds\n"),
 	     idx, section_name (ebl, idx), cnt - 2);
+    }
 
   for (; cnt < 2 + nbucket + nchain; ++cnt)
-    if (((Elf32_Word *) data->d_buf)[cnt] >= maxidx)
+    {
+      if (buf + cnt >= end)
+	break;
+      else if (buf[cnt] >= maxidx)
       ERROR (gettext ("\
 section [%2d] '%s': hash chain reference %zu out of bounds\n"),
 	     idx, section_name (ebl, idx), cnt - 2 - nbucket);
+    }
 }
 
 
@@ -1972,18 +2010,28 @@ section [%2d] '%s': hash table section i
       maxidx = symsize;
     }
 
+  Elf64_Xword *buf = (Elf64_Xword *) data->d_buf;
+  Elf64_Xword *end = (Elf64_Xword *) ((char *) data->d_buf + shdr->sh_size);
   size_t cnt;
   for (cnt = 2; cnt < 2 + nbucket; ++cnt)
-    if (((Elf64_Xword *) data->d_buf)[cnt] >= maxidx)
+    {
+      if (buf + cnt >= end)
+	break;
+      else if (buf[cnt] >= maxidx)
       ERROR (gettext ("\
 section [%2d] '%s': hash bucket reference %zu out of bounds\n"),
 	     idx, section_name (ebl, idx), cnt - 2);
+    }
 
   for (; cnt < 2 + nbucket + nchain; ++cnt)
-    if (((Elf64_Xword *) data->d_buf)[cnt] >= maxidx)
+    {
+      if (buf + cnt >= end)
+	break;
+      else if (buf[cnt] >= maxidx)
       ERROR (gettext ("\
 section [%2d] '%s': hash chain reference %" PRIu64 " out of bounds\n"),
-	     idx, section_name (ebl, idx), (uint64_t) (cnt - 2 - nbucket));
+	       idx, section_name (ebl, idx), (uint64_t) cnt - 2 - nbucket);
+    }
 }
 
 
@@ -2008,7 +2056,7 @@ section [%2d] '%s': bitmask size not pow
   if (shdr->sh_size < (4 + bitmask_words + nbuckets) * sizeof (Elf32_Word))
     {
       ERROR (gettext ("\
-section [%2d] '%s': hash table section is too small (is %ld, expected at least%ld)\n"),
+section [%2d] '%s': hash table section is too small (is %ld, expected at least %ld)\n"),
 	     idx, section_name (ebl, idx), (long int) shdr->sh_size,
 	     (long int) ((4 + bitmask_words + nbuckets) * sizeof (Elf32_Word)));
       return;
@@ -2680,8 +2728,9 @@ section [%2d] '%s' refers in sh_link to 
 
   /* The number of elements in the version symbol table must be the
      same as the number of symbols.  */
-  if (shdr->sh_size / shdr->sh_entsize
-      != symshdr->sh_size / symshdr->sh_entsize)
+  if (shdr->sh_entsize && symshdr->sh_entsize
+      && (shdr->sh_size / shdr->sh_entsize
+	  != symshdr->sh_size / symshdr->sh_entsize))
     ERROR (gettext ("\
 section [%2d] '%s' has different number of entries than symbol table [%2d] '%s'\n"),
 	   idx, section_name (ebl, idx),
--- elfutils/src/readelf.c
+++ elfutils/src/readelf.c
@@ -1136,6 +1136,8 @@ handle_scngrp (Ebl *ebl, Elf_Scn *scn, G
   Elf32_Word *grpref = (Elf32_Word *) data->d_buf;
 
   GElf_Sym sym_mem;
+  GElf_Sym *sym = gelf_getsym (symdata, shdr->sh_info, &sym_mem);
+
   printf ((grpref[0] & GRP_COMDAT)
 	  ? ngettext ("\
 \nCOMDAT section group [%2zu] '%s' with signature '%s' contains %zu entry:\n",
@@ -1148,8 +1150,8 @@ handle_scngrp (Ebl *ebl, Elf_Scn *scn, G
 		      data->d_size / sizeof (Elf32_Word) - 1),
 	  elf_ndxscn (scn),
 	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name),
-	  elf_strptr (ebl->elf, symshdr->sh_link,
-		      gelf_getsym (symdata, shdr->sh_info, &sym_mem)->st_name)
+	  (sym == NULL ? NULL
+	   : elf_strptr (ebl->elf, symshdr->sh_link, sym->st_name))
 	  ?: gettext ("<INVALID SYMBOL>"),
 	  data->d_size / sizeof (Elf32_Word) - 1);
 
@@ -1300,7 +1302,8 @@ static void
 handle_dynamic (Ebl *ebl, Elf_Scn *scn, GElf_Shdr *shdr)
 {
   int class = gelf_getclass (ebl->elf);
-  GElf_Shdr glink;
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink;
   Elf_Data *data;
   size_t cnt;
   size_t shstrndx;
@@ -1315,6 +1318,11 @@ handle_dynamic (Ebl *ebl, Elf_Scn *scn, 
     error (EXIT_FAILURE, 0,
 	   gettext ("cannot get section header string table index"));
 
+  glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link), &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   printf (ngettext ("\
 \nDynamic segment contains %lu entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
 		    "\
@@ -1324,9 +1332,7 @@ handle_dynamic (Ebl *ebl, Elf_Scn *scn, 
 	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
 	  shdr->sh_offset,
 	  (int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
   fputs_unlocked (gettext ("  Type              Value\n"), stdout);
 
   for (cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
@@ -1826,6 +1832,13 @@ handle_symtab (Ebl *ebl, Elf_Scn *scn, G
     error (EXIT_FAILURE, 0,
 	   gettext ("cannot get section header string table index"));
 
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   /* Now we can compute the number of entries in the section.  */
   unsigned int nsyms = data->d_size / (class == ELFCLASS32
 				       ? sizeof (Elf32_Sym)
@@ -1836,15 +1849,12 @@ handle_symtab (Ebl *ebl, Elf_Scn *scn, G
 		    nsyms),
 	  (unsigned int) elf_ndxscn (scn),
 	  elf_strptr (ebl->elf, shstrndx, shdr->sh_name), nsyms);
-  GElf_Shdr glink;
   printf (ngettext (" %lu local symbol  String table: [%2u] '%s'\n",
 		    " %lu local symbols  String table: [%2u] '%s'\n",
 		    shdr->sh_info),
 	  (unsigned long int) shdr->sh_info,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   fputs_unlocked (class == ELFCLASS32
 		  ? gettext ("\
@@ -2080,7 +2090,13 @@ handle_verneed (Ebl *ebl, Elf_Scn *scn, 
     error (EXIT_FAILURE, 0,
 	   gettext ("cannot get section header string table index"));
 
-  GElf_Shdr glink;
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   printf (ngettext ("\
 \nVersion needs section [%2u] '%s' contains %d entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
 		    "\
@@ -2091,9 +2107,7 @@ handle_verneed (Ebl *ebl, Elf_Scn *scn, 
 	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
 	  shdr->sh_offset,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   unsigned int offset = 0;
   for (int cnt = shdr->sh_info; --cnt >= 0; )
@@ -2146,8 +2160,14 @@ handle_verdef (Ebl *ebl, Elf_Scn *scn, G
     error (EXIT_FAILURE, 0,
 	   gettext ("cannot get section header string table index"));
 
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   int class = gelf_getclass (ebl->elf);
-  GElf_Shdr glink;
   printf (ngettext ("\
 \nVersion definition section [%2u] '%s' contains %d entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
 		    "\
@@ -2159,9 +2179,7 @@ handle_verdef (Ebl *ebl, Elf_Scn *scn, G
 	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
 	  shdr->sh_offset,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   unsigned int offset = 0;
   for (int cnt = shdr->sh_info; --cnt >= 0; )
@@ -2423,8 +2441,14 @@ handle_versym (Ebl *ebl, Elf_Scn *scn, G
       filename = NULL;
     }
 
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    error (EXIT_FAILURE, 0, gettext ("invalid sh_link value in section %Zu"),
+	   elf_ndxscn (scn));
+
   /* Print the header.  */
-  GElf_Shdr glink;
   printf (ngettext ("\
 \nVersion symbols section [%2u] '%s' contains %d entry:\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'",
 		    "\
@@ -2436,9 +2460,7 @@ handle_versym (Ebl *ebl, Elf_Scn *scn, G
 	  class == ELFCLASS32 ? 10 : 18, shdr->sh_addr,
 	  shdr->sh_offset,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   /* Now we can finally look at the actual contents of this section.  */
   for (unsigned int cnt = 0; cnt < shdr->sh_size / shdr->sh_entsize; ++cnt)
@@ -2490,7 +2512,17 @@ print_hash_info (Ebl *ebl, Elf_Scn *scn,
   for (Elf32_Word cnt = 0; cnt < nbucket; ++cnt)
     ++counts[lengths[cnt]];
 
-  GElf_Shdr glink;
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink = gelf_getshdr (elf_getscn (ebl->elf,
+					       shdr->sh_link),
+				   &glink_mem);
+  if (glink == NULL)
+    {
+      error (0, 0, gettext ("invalid sh_link value in section %Zu"),
+	     elf_ndxscn (scn));
+      return;
+    }
+
   printf (ngettext ("\
 \nHistogram for bucket list length in section [%2u] '%s' (total of %d bucket):\n Addr: %#0*" PRIx64 "  Offset: %#08" PRIx64 "  Link to section: [%2u] '%s'\n",
 		    "\
@@ -2503,9 +2535,7 @@ print_hash_info (Ebl *ebl, Elf_Scn *scn,
 	  shdr->sh_addr,
 	  shdr->sh_offset,
 	  (unsigned int) shdr->sh_link,
-	  elf_strptr (ebl->elf, shstrndx,
-		      gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link),
-				    &glink)->sh_name));
+	  elf_strptr (ebl->elf, shstrndx, glink->sh_name));
 
   if (extrastr != NULL)
     fputs (extrastr, stdout);
@@ -4107,6 +4137,16 @@ print_debug_aranges_section (Dwfl_Module
       return;
     }
 
+  GElf_Shdr glink_mem;
+  GElf_Shdr *glink;
+  glink = gelf_getshdr (elf_getscn (ebl->elf, shdr->sh_link), &glink_mem);
+  if (glink == NULL)
+    {
+      error (0, 0, gettext ("invalid sh_link value in section %Zu"),
+	     elf_ndxscn (scn));
+      return;
+    }
+
   printf (ngettext ("\
 \nDWARF section [%2zu] '%s' at offset %#" PRIx64 " contains %zu entry:\n",
 		    "\
--- elfutils/src/strip.c
+++ elfutils/src/strip.c
@@ -544,6 +544,11 @@ handle_elf (int fd, Elf *elf, const char
       goto fail_close;
     }
 
+  if (shstrndx >= shnum)
+    goto illformed;
+
+#define elf_assert(test) do { if (!(test)) goto illformed; } while (0)
+
   /* Storage for section information.  We leave room for two more
      entries since we unconditionally create a section header string
      table.  Maybe some weird tool created an ELF file without one.
@@ -565,7 +570,7 @@ handle_elf (int fd, Elf *elf, const char
     {
       /* This should always be true (i.e., there should not be any
 	 holes in the numbering).  */
-      assert (elf_ndxscn (scn) == cnt);
+      elf_assert (elf_ndxscn (scn) == cnt);
 
       shdr_info[cnt].scn = scn;
 
@@ -578,6 +583,7 @@ handle_elf (int fd, Elf *elf, const char
 					shdr_info[cnt].shdr.sh_name);
       if (shdr_info[cnt].name == NULL)
 	{
+	illformed:
 	  error (0, 0, gettext ("illformed file '%s'"), fname);
 	  goto fail_close;
 	}
@@ -587,6 +593,8 @@ handle_elf (int fd, Elf *elf, const char
 
       /* Remember the shdr.sh_link value.  */
       shdr_info[cnt].old_sh_link = shdr_info[cnt].shdr.sh_link;
+      if (shdr_info[cnt].old_sh_link >= shnum)
+	goto illformed;
 
       /* Sections in files other than relocatable object files which
 	 are not loaded can be freely moved by us.  In relocatable
@@ -599,7 +607,7 @@ handle_elf (int fd, Elf *elf, const char
 	 appropriate reference.  */
       if (unlikely (shdr_info[cnt].shdr.sh_type == SHT_SYMTAB_SHNDX))
 	{
-	  assert (shdr_info[shdr_info[cnt].shdr.sh_link].symtab_idx == 0);
+	  elf_assert (shdr_info[shdr_info[cnt].shdr.sh_link].symtab_idx == 0);
 	  shdr_info[shdr_info[cnt].shdr.sh_link].symtab_idx = cnt;
 	}
       else if (unlikely (shdr_info[cnt].shdr.sh_type == SHT_GROUP))
@@ -616,7 +624,12 @@ handle_elf (int fd, Elf *elf, const char
 	  for (inner = 1;
 	       inner < shdr_info[cnt].data->d_size / sizeof (Elf32_Word);
 	       ++inner)
+	    {
+	      if (grpref[inner] < shnum)
 	    shdr_info[grpref[inner]].group_idx = cnt;
+	      else
+		goto illformed;
+	    }
 
 	  if (inner == 1 || (inner == 2 && (grpref[0] & GRP_COMDAT) == 0))
 	    /* If the section group contains only one element and this
@@ -627,7 +640,7 @@ handle_elf (int fd, Elf *elf, const char
 	}
       else if (unlikely (shdr_info[cnt].shdr.sh_type == SHT_GNU_versym))
 	{
-	  assert (shdr_info[shdr_info[cnt].shdr.sh_link].version_idx == 0);
+	  elf_assert (shdr_info[shdr_info[cnt].shdr.sh_link].version_idx == 0);
 	  shdr_info[shdr_info[cnt].shdr.sh_link].version_idx = cnt;
 	}
 
@@ -635,7 +648,7 @@ handle_elf (int fd, Elf *elf, const char
 	 discarded right away.  */
       if ((shdr_info[cnt].shdr.sh_flags & SHF_GROUP) != 0)
 	{
-	  assert (shdr_info[cnt].group_idx != 0);
+	  elf_assert (shdr_info[cnt].group_idx != 0);
 
 	  if (shdr_info[shdr_info[cnt].group_idx].idx == 0)
 	    {
@@ -710,11 +723,15 @@ handle_elf (int fd, Elf *elf, const char
 	    {
 	      /* If a relocation section is marked as being removed make
 		 sure the section it is relocating is removed, too.  */
-	      if ((shdr_info[cnt].shdr.sh_type == SHT_REL
+	      if (shdr_info[cnt].shdr.sh_type == SHT_REL
 		   || shdr_info[cnt].shdr.sh_type == SHT_RELA)
-		  && shdr_info[shdr_info[cnt].shdr.sh_info].idx != 0)
+		{
+		  if (shdr_info[cnt].shdr.sh_info >= shnum)
+		    goto illformed;
+		  else if (shdr_info[shdr_info[cnt].shdr.sh_info].idx != 0)
 		shdr_info[cnt].idx = 1;
 	    }
+	    }
 
 	  if (shdr_info[cnt].idx == 1)
 	    {
@@ -741,7 +758,7 @@ handle_elf (int fd, Elf *elf, const char
 		  if (shdr_info[cnt].symtab_idx != 0
 		      && shdr_info[shdr_info[cnt].symtab_idx].data == NULL)
 		    {
-		      assert (shdr_info[cnt].shdr.sh_type == SHT_SYMTAB);
+		      elf_assert (shdr_info[cnt].shdr.sh_type == SHT_SYMTAB);
 
 		      shdr_info[shdr_info[cnt].symtab_idx].data
 			= elf_getdata (shdr_info[shdr_info[cnt].symtab_idx].scn,
@@ -781,6 +798,9 @@ handle_elf (int fd, Elf *elf, const char
 		      else if (scnidx == SHN_XINDEX)
 			scnidx = xndx;
 
+		      if (scnidx >= shnum)
+			goto illformed;
+
 		      if (shdr_info[scnidx].idx == 0)
 			/* This symbol table has a real symbol in
 			   a discarded section.  So preserve the
@@ -811,12 +831,16 @@ handle_elf (int fd, Elf *elf, const char
 		}
 
 	      /* Handle references through sh_info.  */
-	      if (SH_INFO_LINK_P (&shdr_info[cnt].shdr)
-		  && shdr_info[shdr_info[cnt].shdr.sh_info].idx == 0)
+	      if (SH_INFO_LINK_P (&shdr_info[cnt].shdr))
+		{
+		  if (shdr_info[cnt].shdr.sh_info >= shnum)
+		    goto illformed;
+		  else if ( shdr_info[shdr_info[cnt].shdr.sh_info].idx == 0)
 		{
 		  shdr_info[shdr_info[cnt].shdr.sh_info].idx = 1;
 		  changes |= shdr_info[cnt].shdr.sh_info < cnt;
 		}
+		}
 
 	      /* Mark the section as investigated.  */
 	      shdr_info[cnt].idx = 2;
@@ -955,7 +979,7 @@ handle_elf (int fd, Elf *elf, const char
 	  error (EXIT_FAILURE, 0, gettext ("while generating output file: %s"),
 		 elf_errmsg (-1));
 
-	assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
+	elf_assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
 
 	/* Add this name to the section header string table.  */
 	shdr_info[cnt].se = ebl_strtabadd (shst, shdr_info[cnt].name, 0);
@@ -992,7 +1016,7 @@ handle_elf (int fd, Elf *elf, const char
 	error (EXIT_FAILURE, 0,
 	       gettext ("while create section header section: %s"),
 	       elf_errmsg (-1));
-      assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
+      elf_assert (elf_ndxscn (shdr_info[cnt].newscn) == shdr_info[cnt].idx);
 
       shdr_info[cnt].data = elf_newdata (shdr_info[cnt].newscn);
       if (shdr_info[cnt].data == NULL)
@@ -1048,7 +1072,7 @@ handle_elf (int fd, Elf *elf, const char
     error (EXIT_FAILURE, 0,
 	   gettext ("while create section header section: %s"),
 	   elf_errmsg (-1));
-  assert (elf_ndxscn (shdr_info[cnt].newscn) == idx);
+  elf_assert (elf_ndxscn (shdr_info[cnt].newscn) == idx);
 
   /* Finalize the string table and fill in the correct indices in the
      section headers.  */
@@ -1138,20 +1162,20 @@ handle_elf (int fd, Elf *elf, const char
 		    shndxdata = elf_getdata (shdr_info[shdr_info[cnt].symtab_idx].scn,
 					     NULL);
 
-		    assert ((versiondata->d_size / sizeof (Elf32_Word))
+		    elf_assert ((versiondata->d_size / sizeof (Elf32_Word))
 			    >= shdr_info[cnt].data->d_size / elsize);
 		  }
 
 		if (shdr_info[cnt].version_idx != 0)
 		  {
-		    assert (shdr_info[cnt].shdr.sh_type == SHT_DYNSYM);
+		    elf_assert (shdr_info[cnt].shdr.sh_type == SHT_DYNSYM);
 		    /* This section has associated version
 		       information.  We have to modify that
 		       information, too.  */
 		    versiondata = elf_getdata (shdr_info[shdr_info[cnt].version_idx].scn,
 					       NULL);
 
-		    assert ((versiondata->d_size / sizeof (GElf_Versym))
+		    elf_assert ((versiondata->d_size / sizeof (GElf_Versym))
 			    >= shdr_info[cnt].data->d_size / elsize);
 		  }
 
@@ -1206,7 +1230,7 @@ handle_elf (int fd, Elf *elf, const char
 		      sec = shdr_info[sym->st_shndx].idx;
 		    else
 		      {
-			assert (shndxdata != NULL);
+			elf_assert (shndxdata != NULL);
 
 			sec = shdr_info[xshndx].idx;
 		      }
@@ -1227,7 +1251,7 @@ handle_elf (int fd, Elf *elf, const char
 			    nxshndx = sec;
 			  }
 
-			assert (sec < SHN_LORESERVE || shndxdata != NULL);
+			elf_assert (sec < SHN_LORESERVE || shndxdata != NULL);
 
 			if ((inner != destidx || nshndx != sym->st_shndx
 			     || (shndxdata != NULL && nxshndx != xshndx))
@@ -1251,7 +1275,7 @@ handle_elf (int fd, Elf *elf, const char
 			     || shdr_info[cnt].debug_data == NULL)
 		      /* This is a section symbol for a section which has
 			 been removed.  */
-		      assert (GELF_ST_TYPE (sym->st_info) == STT_SECTION);
+		      elf_assert (GELF_ST_TYPE (sym->st_info) == STT_SECTION);
 		  }
 
 		if (destidx != inner)
@@ -1438,11 +1462,11 @@ handle_elf (int fd, Elf *elf, const char
 		  {
 		    GElf_Sym sym_mem;
 		    GElf_Sym *sym = gelf_getsym (symd, inner, &sym_mem);
-		    assert (sym != NULL);
+		    elf_assert (sym != NULL);
 
 		    const char *name = elf_strptr (elf, strshndx,
 						   sym->st_name);
-		    assert (name != NULL);
+		    elf_assert (name != NULL);
 		    size_t hidx = elf_hash (name) % nbucket;
 
 		    if (bucket[hidx] == 0)
@@ -1461,7 +1485,7 @@ handle_elf (int fd, Elf *elf, const char
 	    else
 	      {
 		/* Alpha and S390 64-bit use 64-bit SHT_HASH entries.  */
-		assert (shdr_info[cnt].shdr.sh_entsize
+		elf_assert (shdr_info[cnt].shdr.sh_entsize
 			== sizeof (Elf64_Xword));
 
 		Elf64_Xword *bucket = (Elf64_Xword *) hashd->d_buf;
@@ -1492,11 +1516,11 @@ handle_elf (int fd, Elf *elf, const char
 		  {
 		    GElf_Sym sym_mem;
 		    GElf_Sym *sym = gelf_getsym (symd, inner, &sym_mem);
-		    assert (sym != NULL);
+		    elf_assert (sym != NULL);
 
 		    const char *name = elf_strptr (elf, strshndx,
 						   sym->st_name);
-		    assert (name != NULL);
+		    elf_assert (name != NULL);
 		    size_t hidx = elf_hash (name) % nbucket;
 
 		    if (bucket[hidx] == 0)
